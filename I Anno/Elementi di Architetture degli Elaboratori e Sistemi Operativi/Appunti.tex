% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\documentclass[
]{article}
\usepackage{xcolor}
\usepackage{amsmath,amssymb}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math} % this also loads fontspec
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else
  % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\newsavebox\pandoc@box
\newcommand*\pandocbounded[1]{% scales image to fit in text height/width
  \sbox\pandoc@box{#1}%
  \Gscale@div\@tempa{\textheight}{\dimexpr\ht\pandoc@box+\dp\pandoc@box\relax}%
  \Gscale@div\@tempb{\linewidth}{\wd\pandoc@box}%
  \ifdim\@tempb\p@<\@tempa\p@\let\@tempa\@tempb\fi% select the smaller of both
  \ifdim\@tempa\p@<\p@\scalebox{\@tempa}{\usebox\pandoc@box}%
  \else\usebox{\pandoc@box}%
  \fi%
}
% Set default figure placement to htbp
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\usepackage{bookmark}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}

{}

{INTRODUZIONE}

{}

{Informatica → dal francese ``}{Informatique}{'' = Information +
Automatique}

{~ ~ ~ ~ ↓}

{Insieme di tecnologie di tipo elettronico utili per creare,
immagazzinare e elaborare }{informazioni}{.}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↓}

{~ ~ ~ ~ ~Informare vuol dire dare forma a qualcosa, rendere consapevole
~ ~ ~ ~ ~ ~ ~qualcuno }

{}

{La minima informazione è il bit (Binary Digit) cioè
l\textquotesingle unità di informazione necessaria per la scelta
effettuata tra due soli eventi ( 0 e 1, vero e falso); in modo da
diminuire l'incertezza.}

{}

{}

\paragraph{\texorpdfstring{{Sistema informatico VS Sistema
informativo}}{Sistema informatico VS Sistema informativo}}\label{h.ifxnqepgtsj6}

{Sistema informativo}{→ Ha lo scopo di produrre ``in tempo utile'',
nelle ``forme appropriate'', ed ai ``giusti livelli'' le sintesi
necessarie per i processi decisionali. }

{}

{Sistema informatico }{→ sottoinsieme del sistema informativo dedicato
alla gestione automatica di informazioni; quindi è l'insieme di parti
con l'obiettivo di archiviare, elaborare e raccogliere informazioni in
maniera elettronica.}

{}

{}

\paragraph{\texorpdfstring{{Computer}}{Computer}}\label{h.au2vel7tzgss}

{Il computer è un }{elaboratore}{~}{elettronico digitale}{:}

{}

\begin{itemize}
\tightlist
\item
  {Elaboratore}{: macchina in grado di immagazzinare ed elaborare dati
  in base ad una serie di istruzioni;}
\item
  {Elettronico}{: utilizza componenti elettronici per elaborare le
  informazioni;}
\item
  {Digitale}{: i dati sono memorizzati mediante cifre binarie;}
\end{itemize}

{}

{Il calcolatore al suo interno è diviso in:}

{}

\begin{itemize}
\tightlist
\item
  {Hardware}{: l'insieme di dispositivi (fisici) che compongono il
  calcolatore;}
\item
  {Software}{: istruzioni e informazioni necessarie per risolvere i
  problemi;}
\item
  {Firmware}{: è il confine fra le due parti precedenti, microprogrammi
  scritti dai costruttori o memorizzati su speciali memorie.}
\end{itemize}

{}

{}

\paragraph{\texorpdfstring{{Storia del
calcolatore}}{Storia del calcolatore}}\label{h.39yd0g1lvkew}

{Esistono diverse generazioni di calcolatori, ecco quali:}

{}

\begin{enumerate}
\tightlist
\item
  {Gen 0 {[}calcolatori meccanici{]}}{: Il primo a costruire macchine
  calcolatrici automatiche fu lo scienziato francese Blaise Pascal
  (Pascalina), un dispositivo a ingranaggi azionati per mezzo di una
  manovella e in grado di effettuare addizioni e sottrazioni; aggiornata
  da Gottfried in modo da fare moltiplicazioni e divisioni.}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Gen 1 {[}valvole termoioniche e relè{]}}{: Massachusetts Institute of
  Technology progettò il Differential Analyzer. Questa macchina era in
  grado di risolvere equazioni differenziali; il primo dei calcolatori
  }{elettrici}{~e digitali.}
\end{enumerate}

{Alan Mathison Turing riuscì a decrittografare i messaggi tedeschi
usando un calcolatore elettromeccanico che poteva lavorare ad altissima
velocità (Colossus).}

{Negli anni successivi alla guerra vennero sviluppati gli ENIAC
(Electronic Numerical Integrator And Computer), tra ~i consulenti c'era
Von Neumann che progettò l'EDVAC composto da registri dentro la CPU
(composta a sua volta da Unità di controllo e aritmetico logica, ALU) e
una memoria principale tutto collegato con bus.}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image47.png}}}

{Prima di ciò Von Neumann e altri progettarono IAS, denominata macchina
di Von Neumann, una pietra miliare dell'informatica, che influenzò
pesantemente lo sviluppo di tutti i calcolatori successivi. }

{In questa Gen per la priva volta si utilizzano gli 0 e 1 (accesso
spento).}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Gen 2 {[}i transistor{]}}{: }{il transistor}{~fu inventato nel 1948
  alla Bell Labs e fruttò ai suoi inventori il premio Nobel per la
  fisica.}
\end{enumerate}

{Primo passo verso la miniaturizzazione che portò alla creazione di
hardware meno ingombranti, più veloci e meno dispendiosi.}

{Anni `60 la DEC produce il PDP-8 con il BUS.}

{Inizia la miniaturizzazione.}

{}

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {Gen 3 {[}circuiti integrati{]}}{: inventati nel 1958 da Robert Noyce
  permisero di inserire dozzine di transistor su un singolo pezzo di
  silicio e quindi favorirono la costruzione di calcolatori più piccoli,
  più veloci e meno costosi.}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{4}
\tightlist
\item
  {Gen 4 {[}Very Large Scale Integration{]}}{: nel 1971 tre ingegneri
  della Intel crearono il primo microprocessore; comincia così l'era dei
  }
\end{enumerate}

{PC.}

{Nel 1975 William Gates e Paul Allen, diedero vita a una piccolissima
azienda che elaborava linguaggi per "computer": la Microsoft. Nello
stesso periodo Steve Jobs e Stephen Wozniak costruirono }{''Apple
I''}{.}

{}

\begin{enumerate}
\setcounter{enumi}{5}
\tightlist
\item
  {Gen 5 {[}Quantistico \& I.A.{]}}{: sviluppo dell'hardware attraverso
  i computer quantistici, basati non più sul concetto di bit ma di
  }{qbit}{~e lo sviluppo del software attraverso l'implementazione delle
  intelligenze artificiali.}
\end{enumerate}

{Nel prossimo futuro i calcolatori saranno sempre più veloci e capaci di
autoprogrammarsi.}

{}

{Esiste una ``legge'' che stima come i computer aumentino di potenza
ogni 18 mesi, andando a raddoppiare il numero di transistor su un
singolo chip; è la }{legge di Moore}{.}

{}

{}

{}

{RAPPRESENTAZIONE DIGITALE DELL'INFORMAZIONE}

{}

{L'informazione può essere rappresentata in modo:}

{}

\begin{itemize}
\tightlist
\item
  {Digitale}{: Ogni dato viene codificato impiegando entità distinte
  individualmente e organizzate in modo opportuno;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Analogica}{: Basata sull'impiego di dispositivi che realizzano una
  grandezza fisica che può variare in modo continuo.}
\end{itemize}

{}

{}

\paragraph{\texorpdfstring{{NUMERI A PRECISIONE
FINITA}}{NUMERI A PRECISIONE FINITA}}\label{h.260ywngm6g79}

{Rappresentati con un numero finito di cifre, le operazioni con questi
numeri possono causare i seguenti errori se il loro risultato non
appartiene all'insieme dei valori rappresentabili:}

{}

\begin{itemize}
\tightlist
\item
  {Underflow}{: il risultato è minore del più piccolo valore
  rappresentabile;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Overflow}{: il risultato è maggiore del più grande valore
  rappresentabile;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Non appartenenza all'insieme}{: il risultato non appartiene
  all'insieme dei valori rappresentabili.}
\end{itemize}

{}

{L'algebra dei numeri a precisione finita è diversa da quella
convenzionale, ~la proprietà distributiva e la proprietà associativa non
sono rispettate.}

{}

{}

\paragraph{\texorpdfstring{{NUMERI
FLOATING-POINT}}{NUMERI FLOATING-POINT}}\label{h.gsbyxjj17nq1}

{Per il trattamento di valori razionali o reali si adotta una notazione
in cui la gamma dei valori esprimibili è indipendente dal numero di
cifre significative. Questo sistema è detto floating-point. Esprimibile
nel seguente modo:}

{}

\pandocbounded{\includegraphics[keepaspectratio]{images/image1.png}}{~
~}\pandocbounded{\includegraphics[keepaspectratio]{images/image2.png}}\pandocbounded{\includegraphics[keepaspectratio]{images/image3.png}}

{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ~ ~ ~ ~↓ ~ ~ ~ ~ ~}

{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ }{mantissa}

{La precisione è determinata dalla mantissa }{f}{, mentre la gamma dei
valori è determinato dall'esponente}{~e}{.}

{Uno standard permette di valorizzare la mantissa (f) solo in un range
fra 0.1 e 1
(}\pandocbounded{\includegraphics[keepaspectratio]{images/image4.png}}{).}

{}

\pandocbounded{\includegraphics[keepaspectratio]{images/image5.png}}{~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
}\pandocbounded{\includegraphics[keepaspectratio]{images/image6.png}}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~}{~}{sbagliato ~ }{f ~\textgreater{} 1}{~ ~ }{~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~}{~corretto
}\pandocbounded{\includegraphics[keepaspectratio]{images/image4.png}}

\subparagraph{\texorpdfstring{{}}{}}\label{h.ub3l7wehv5o7}

\subparagraph{\texorpdfstring{{IEEE
754}}{IEEE 754}}\label{h.6bqkz7ejw0m1}

{Con l'introduzione del seguente standard si sono uniti tutti i
calcolatori su un unico formato per i floating-point binari. Ne esistono
3 formati:}

{}

\begin{enumerate}
\tightlist
\item
  {Singola precisione}{: Totale 32 bit {[}1 per il segno, 8 per gli
  esponenti, 23 mantissa{]};}
\item
  {Doppia precisione}{: Totale 64 bit {[}1 per il segno, 11 per gli
  esponenti, 52 mantissa{]};}
\item
  {Precisione estesa}{;}
\end{enumerate}

{}

{Per calcolare l'eccesso ~si usa la formula
}\pandocbounded{\includegraphics[keepaspectratio]{images/image7.png}}{,
con n = numero di bit.}

{Per calcolare in numero decimale avente il numero binario floating
point si fa così:}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image54.png}}}

\subparagraph{\texorpdfstring{{}}{}}\label{h.7759ib91rex3}

\subparagraph{\texorpdfstring{{}}{}}\label{h.92j84hyrid2f}

\subparagraph{\texorpdfstring{{Es:}}{Es:}}\label{h.bhrm8qeihpjo}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image46.png}}}

{}

{}

\subparagraph{\texorpdfstring{{Normalizzazione}}{Normalizzazione}}\label{h.9m46o6vkrx4v}

{La mantissa binaria normalizzata deve presentare un 1 a sinistra della
virgola binaria. L'esponente deve essere aggiustato di conseguenza.}

{}

{Esempio di normalizzazione:}

{}

\pandocbounded{\includegraphics[keepaspectratio]{images/image8.png}}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image41.png}}}{cambiamo
la base}

{1000111011000.0011}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image41.png}}}{normalizzo
spostando la virgola di tot posizioni in modo da avere un 1. davanti}

{1.0001110110000011 *
}\pandocbounded{\includegraphics[keepaspectratio]{images/image9.png}}{~{[}12
sono le pos. spostate{]}}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image41.png}}}{esprimo
l'esponente in eccesso (127)}

{12 + 127 = 139 → 10001011 ~ ~ ~ ~}{~}{~}{{[}il 127 è dato da
}\pandocbounded{\includegraphics[keepaspectratio]{images/image10.png}}{~dove
n = num. bit esponente{]}}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image41.png}}}{rappresento
il tutto in modo corretto}

{0}{~}{1 0 0 0 1 0 1 1}{~}{0 0 0 1 1 1 0 1 1 0 0 0 0 0 1 1 0 0 0 0 0 0
0}

{↓ ~ ~ ~ ~ ~ ~ ~ ~}{↓ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ }{↓}

{segno ~ ~ ~ ~}{esponente ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~}{mantissa
normalizzata}

{}

\paragraph{\texorpdfstring{{SISTEMI DI NUMERAZIONE
INFORMATICA}}{SISTEMI DI NUMERAZIONE INFORMATICA}}\label{h.7y7wowmqgj3}

{I sistemi di numerazione più utilizzati in informatica:}

{}

\begin{itemize}
\tightlist
\item
  {Sistema decimale (base=10) 0 1 2 3 4 5 6 7 8 9 ;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Sistema binario (base=2) 0 1: ogni cifra, detta bit (Binary digIT),
  può essere rappresentata direttamente tramite un livello elettrico di
  tensione ;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Sistema ottale (base=8) 0 1 2 3 4 5 6 7;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Sistema esadecimale (base=16) 0 1 2 3 4 5 6 7 8 9 A B C D E F: è
  utilizzato poiché è molto compatto e ben si presta alla traduzione in
  valori binari, poiché ogni cifra corrisponde esattamente a 4 cifre
  binarie. }
\end{itemize}

{}

{Tutti questi sistemi sono a notazione posizionale, i sistemi di
numerazione posizionale associano alle cifre un diverso valore in base
alla posizione che occupano nella stringa che compone il numero. }

{}

{}

\paragraph{\texorpdfstring{{CONVERSIONI TRA
BASI}}{CONVERSIONI TRA BASI}}\label{h.ixpima60nzrk}

{}

{Tabella utile per le conversioni:}

{}

\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{BINARIO} & {OTTALE}{/}{ESADECIMALE} \\
{0000} & {0} \\
{0001} & {1} \\
{0010} & {2} \\
{0011} & {3} \\
{0100} & {4} \\
{0101} & {5} \\
{0110} & {6} \\
{0111} & {7} \\
{1000} & {8} \\
{1001} & {9} \\
{1010} & {A} \\
{1011} & {B} \\
{1100} & {C} \\
{1101} & {D} \\
{1110} & {E} \\
{1111} & {F} \\
\end{longtable}

{}

{}

\subparagraph{\texorpdfstring{{Binario →
Decimale}}{Binario → Decimale}}\label{h.twy0m6pz1o3g}

{Per convertire qualsiasi numero binario in uno decimale basta
moltiplicare il numero per la base elevata alla posizione.}

{}

{Es: ~1 0 0 1 1 0 0 1}

{~ ~ ~ ~ }{7 ~6 ~ 5 ~ 4 ~ 3 ~ 2 ~ 1 ~0}

{~ ~ ~ }

{~ ~
}{~}{1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image11.png}}{~
+
~1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image12.png}}{~+
~1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image13.png}}{~+
~}{1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image14.png}}{~
= ~128 + 16 + 8 + 1 = 153}{10 }

{}

{}

{}

{Per convertire una parte frazionaria (Es: 0.101) usiamo lo stesso
ragionamento ma con i numeri ad esponente negativo:}

{}

{Es: ~0.1 0 1}

{~ ~ ~ ~ ~}{~-1 ~-2 ~-3}

{}

{~ ~
}{~}{1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image15.png}}{~
+
~0*}\pandocbounded{\includegraphics[keepaspectratio]{images/image16.png}}{~+
~1*}\pandocbounded{\includegraphics[keepaspectratio]{images/image17.png}}{~}{=
~0,5 + 0 + 0,125 = 0,625}{10 }

{}

{}

\subparagraph{\texorpdfstring{{Ottale →
Decimale}}{Ottale → Decimale}}\label{h.nzmx1ds7uxfi}

{Come prima prendiamo il numero e moltiplichiamo ogni cifra per la base
elevata alla posizione:}

{}

{Es:
}\pandocbounded{\includegraphics[keepaspectratio]{images/image18.png}}{~
}{→
3*}\pandocbounded{\includegraphics[keepaspectratio]{images/image19.png}}{~+
~2*}\pandocbounded{\includegraphics[keepaspectratio]{images/image20.png}}{~=
24 + 2 =
}\pandocbounded{\includegraphics[keepaspectratio]{images/image21.png}}

{}

\subparagraph{\texorpdfstring{{Esadecimale →
Decimale}}{Esadecimale → Decimale}}\label{h.a2rbql489dc6}

{Come prima prendiamo il numero e moltiplichiamo ogni cifra per la base
elevata alla posizione, in questo caso le cifre numeriche si fermano al
9, dal 10 al 15 le cifre diventano lettere (dalla A alla F):}

{}

{Es:
1}\pandocbounded{\includegraphics[keepaspectratio]{images/image22.png}}{~→
}\pandocbounded{\includegraphics[keepaspectratio]{images/image23.png}}{~+
~}\pandocbounded{\includegraphics[keepaspectratio]{images/image24.png}}{~=
16 + 10 =
}\pandocbounded{\includegraphics[keepaspectratio]{images/image21.png}}

{}

\subparagraph{\texorpdfstring{{Binario →
Ottale}}{Binario → Ottale}}\label{h.4ubd3l30fmnh}

{Convertiamo le cifre binarie a gruppi di 3:}

{}

{Es. }{~1 }{0 1 1}{~}{1 1 0 }{→ ( }{001}{) (}{011}{) (}{110}{) ~ ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ }

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~↓ ~ ~ ~ ~↓ ~ ~ ~ ↓}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~1 ~ ~ ~ ~3 ~ ~ ~6 ~ ~= ~
}\pandocbounded{\includegraphics[keepaspectratio]{images/image25.png}}

{}

\subparagraph{\texorpdfstring{{Ottale → Binario
}}{Ottale → Binario }}\label{h.hlmgg1ktiths}

{Procedimento inverso rispetto al precedente:}

{}

{Es:
}\pandocbounded{\includegraphics[keepaspectratio]{images/image25.png}}{~=
( }{001}{) (}{011}{) (}{110}{) ~→ ~}{1 }{0 1 1}{~}{1 1 0}

\subparagraph{\texorpdfstring{{}}{}}\label{h.qr6h52tc44a3}

\subparagraph{\texorpdfstring{{Esadecimale ~→ Binario
}}{Esadecimale ~→ Binario }}\label{h.gsslugn33nlr}

{Convertiamo le cifre esadecimali a gruppi di 4:}

{}

{Es:
}\pandocbounded{\includegraphics[keepaspectratio]{images/image26.png}}{~=
(0111) (1011) (1010) (0011)}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↓ ~ ~ ~ ~ ~ ↓ ~ ~ ~ ~ ↓ ~ ~ ~ ~ ~↓}

{~~~~~~~~~~~~~~~~7~~~~~~~~B~~~~~~~~A~~~~~~~~3~~~~~~~~}

{}

{}

\subparagraph{\texorpdfstring{{Decimale ~→ Binario
}}{Decimale ~→ Binario }}\label{h.cbvfa6umxpgx}

{Esistono due metodi per convertire da base 10 a base 2, ecco quali:}

{}

\begin{itemize}
\tightlist
\item
  {Metodo 1 {[}Generale{]}:}
\end{itemize}

{Si procede sottraendo la più grande potenza di 2 abbastanza grande da
contenere il numero da convertire, andando poi }{a mettere}{~1 nelle
posizioni dell'esponente.}

{}

{Per rendere più veloce il procedimento possiamo fare somme con i
risultati delle potenze di 2, Es:}

{}

{138 = 128 + 8 + 2}

{~ ~ ~ ~ ~ ~ ~↓ ~ ~ ↓ ~ ~ ↓}

{~~~~~~~~~~~~~~~~~~~~~~~~~}\pandocbounded{\includegraphics[keepaspectratio]{images/image11.png}}{~
~}\pandocbounded{\includegraphics[keepaspectratio]{images/image27.png}}{~}\pandocbounded{\includegraphics[keepaspectratio]{images/image28.png}}{~=
10001010}

{}

\begin{itemize}
\tightlist
\item
  {Metodo 2 {[}Divisione{]}:}
\end{itemize}

{In questo metodo andiamo a dividere per 2 il numero e contando se il
resto è 0 o 1, alla fine delle divisioni prendiamo i resti in modo
ricorsivo. Es:}

{}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image50.png}}}\pandocbounded{\includegraphics[keepaspectratio]{images/image29.png}}

{}

{}

{}

{}

\begin{itemize}
\tightlist
\item
  {Conversione parte frazionaria: }
\end{itemize}

{Per convertire la parte a destra della virgola in un numero binario,
dopo aver convertito normalmente la parte intera, dobbiamo moltiplicare
la parte frazionaria per 2, se il risultato è \textgreater{} di 1 allora
sottraiamo 1 per poi andare a moltiplicare di nuovo e ripetere i
~passaggi fino a quando non otteniamo come risultato 1 oppure un
risultato già ottenuto. Esempio:}

{}

{}

{0,6 ~}

{~↓}

{0,6 * 2 = }{1}{,2 (\textgreater1) }

{~↓}

{1,2 -1 = 0,2 }

{~↓}

{0,2 * 2 =}{~0}{,4 (\textless1 niente sottrazione)}

{↓}

{0,4 * 2 = }{0}{,8 (\textless1 niente sottrazione)}

{↓}

{0,8 * 2 = }{1}{,6 (\textgreater1) }

{↓}

{1,6 - 1 = 0,6 (risultato già ottenuto, finiamo qui)}

{}

{Ora per prendere il numero binario andiamo semplicemente a prendere i
}{numeri prima della virgola nei risultati}{~in maniera non
ricorsiva}{~!!!}

{Quindi il risultato sarà:}

{0,6 = 0.1001}

{}

{(non prendo i risultati delle sottrazioni)}

{}

\paragraph{\texorpdfstring{{ARITMETICA DEL
CALCOLATORE}}{ARITMETICA DEL CALCOLATORE}}\label{h.6s7xvf4zsa2v}

{Diversa da quella comunemente utilizzata dalle persone; la precisione
con cui i numeri possono essere espressi è finita.}

{Per rappresentare i numeri si utilizza il sistema binario.}

{La più importante unità di misura dell'informazione manipolata dal
calcolatore è il BYTE, composto da 8 bit; sequenze di bit più lunghe di
un byte sono denominate WORD}{.}

{}

\subparagraph{\texorpdfstring{{Somma}}{Somma}}\label{h.nsq1h9ofd1y0}

{Il procedimento di somma binaria è equivalente a quello nel sistema
decimale con eccezione del riporto che si genera quando entrambi gli
addendi hanno valore 1. Es:}

{}

{}

{0 0 1 1 ~+}

{0 1 0 1 ~=}

{-----------}

{~ ~ ~ ~ ~ ~0 1 1 0 ~}{risultato}

{~ ~ ~ ~ ~0 0 0 1 }{~riporto}

{}

\begin{itemize}
\tightlist
\item
  {La somma è uguale a 1 solo se la coppia di cifre è diversa.}
\item
  {Il riporto è uguale a 1 solo se entrambe le cifre sono uno.}
\item
  {In tutti gli altri casi produce 0.}
\end{itemize}

{}

{L'ultimo riporto viene messo nel risultato}

{}

\subparagraph{\texorpdfstring{{Numeri binari
negativi}}{Numeri binari negativi}}\label{h.b940u07xil7d}

{Prima di vedere la sottrazione bisogna saper negare un numero, esistono
4 metodi:}

{}

\begin{enumerate}
\tightlist
\item
  {Grandezza a segno}{: prevede l'utilizzo del bit più a sinistra per
  indicare il segno: 0 il +, 1 il -. }
\end{enumerate}

{Es:}

{76 -> 01001100 -76 -> 11001100}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Complemento a uno}{: andiamo a negare il numero, invertendo lo 0 con
  l'1 e viceversa.}
\end{enumerate}

{Es:}

{-(76) -> -(01001100) -> 10110011}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Complemento a due}{: prendiamo il numero negato e aggiungiamo 1.}
\end{enumerate}

{Es:}

{-(76) -> -(01001100) -> 10110011 -> 10110100 }

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {Eccesso
  }\pandocbounded{\includegraphics[keepaspectratio]{images/image30.png}}{:
  Rappresenta i numeri come somma di se stessi con 2m-1 }{dove m è}{~il
  numero di bit utilizzati per rappresentare il valore.}
\end{enumerate}

{Es {[}}{con m=8 quindi il num. è memorizzato in un byte}{{]}:}

\pandocbounded{\includegraphics[keepaspectratio]{images/image31.png}}{~
~/ ~ ~-76 -> -76+128 = 52 = 00110100}

{}

\subparagraph{\texorpdfstring{{Sottrazione}}{Sottrazione}}\label{h.kkz4jp2qokpv}

{Con i numeri binari si preferisce sommare un numero positivo ad uno
negativo piuttosto che fare una sottrazione.}

{Si parla quindi di }{somma tra numeri binari in complemento a due}{,
andando a utilizzare questo metodo:}

\begin{itemize}
\tightlist
\item
  {Il riporto generato dai bit più a sinistra viene ignorato. }
\item
  {~Se gli addendi sono di segno opposto non si può verificare un
  overflow.}
\item
  {L'overflow si verifica se il riporto generato nel sommare i bit di
  segno è diverso dal riporto utilizzato per sommare i bit di segno.}
\end{itemize}

{}

{Es:}

{Addendo }{~ 10 ~ 0 0 0 0 1 0 1 0}

{Addendo ~ }{-3 ~ ~1 1 1 1 1 1 0 1}

{------------------------------}

{Somma}{~ ~ ~ 7 ~ ~0 0 0 0 0 1 1 1 }

{Riporti}{~ ~ ~ ~ ~ ~ ~ }{1}{~1 1 1 1 0 0 0}

{~ ~ ↓}

{~ ~ ~ ~riporto ignorato}

{}

\subparagraph{\texorpdfstring{{Prodotto}}{Prodotto}}\label{h.i5q9pqgbblgx}

{Il procedimento del prodotto viene riportato all'addizione in questo
modo: }

\begin{itemize}
\tightlist
\item
  {Ogni cifra 1 del moltiplicatore fa scorrere a sinistra le cifre del
  moltiplicando, aggiungendo tanti 0 quanti ne richiede la sua
  posizione.}
\item
  {I numeri così ottenuti vengono memorizzati e sommati tra di loro.}
\end{itemize}

{}

{Es: ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~}{3 2 1 }{← }{posizioni}

{70}{*14 = }{01000110}{~* 0000}{111}{0}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ↓}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ dovrò sommare il 70 }

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ per se stesso 3 volte (num di 1 = 3) e }

{~ ~ ~ogni volta aggiungere tanti 0 in base alla posizione degli 1}

{}

{~ ~ ~}{~1 0 0 0 1 1 0 }{0}{~+}

{~ ~}{1 0 0 0 1 1 0}{~}{0 0}{~=}

{------------------}

{~ ~1 1 0 1 0 0 1 0 0 +}

{1 0 0 0 1 1 0}{~}{0 0 0}{~= }

{------------------}

{~ ~ ~ ~ ~ ~1 1 1 1 0 1 0 1 0 0 ~=
}\pandocbounded{\includegraphics[keepaspectratio]{images/image32.png}}

{}

{}

{}

{CODIFICA DELL'INFORMAZIONE}

{}

\paragraph{\texorpdfstring{{CODIFICA DEI
CARATTERI}}{CODIFICA DEI CARATTERI}}\label{h.f6nc5ej264w4}

{Ogni calcolatore dispone di un set di caratteri codificati sotto forma
di numeri. La mappatura di essi è detta ``tabella dei caratteri''.}

{}

\subparagraph{\texorpdfstring{{ASCII}}{ASCII}}\label{h.9b0nk3eqtn99}

{Utilizza 7 bit (l'8° usato per il controllo) con 128 combinazioni. I
caratteri da 0 a }{1F sono}{~detti di controllo, non vengono stampati.}

{All'ASCII sono state aggiunte diverse estensioni per aggiungere
caratteri non rappresentabili in precedenza, come ad esempio il
}{Latin-1}{~con 8 bit con l'aggiunta delle lettere latine, accenti,
ecc.}

{}

\subparagraph{\texorpdfstring{{UNICODE}}{UNICODE}}\label{h.bd61yz7hzafz}

{Visto che l'ASCII non poteva rappresentare tutti i caratteri dei vari
alfabeti si è scelto di creare un unico set per tutto il mondo,
l'}{Unicode}{~con 2 byte (16 bit) quindi da 0 65000 circa combinazioni.}

{}

\subparagraph{\texorpdfstring{{UTF-8}}{UTF-8}}\label{h.f3aihekqylam}

{il Consorzio UNICODE ha sviluppato lo standard UTF-8 che prevede una
rappresentazione dinamica dei caratteri da 1 a 4 byte per risolvere i
problemi di compatibilità online fra mittente e destinatario.}

{}

{}

\paragraph{\texorpdfstring{{CODIFICA DELLE
IMMAGINI}}{CODIFICA DELLE IMMAGINI}}\label{h.7eoa772ihr4f}

{Le immagini si dividono in rester (scalari) e vettoriali
(geometriche).}

{}

\subparagraph{\texorpdfstring{{Raster}}{Raster}}\label{h.vxk6bc2xnlur}

{In questa tipologia l'immagine è un insieme di parti distinte che
possono essere codificate separatamente con sequenze di bit. Queste
parti vanno discretizzate (scomposizione dell'immagine in un reticolo di
punti) e quantizzate (codifica di ogni pixel con una sequenza di bit).}

{L'immagine è un insieme di pixel dove ognuno rappresenta un colore che
insieme ad altri vanno a formare un'immagine.}

{La discretizzazione prevede:}

\begin{itemize}
\tightlist
\item
  {Definizione}{: DPI (dot per inches) cioè il numero di pixel;}
\item
  {Risoluzione}{: dimensione griglia.}
\end{itemize}

{}

{La Quantizzazione prevede la rappresentazione di ogni pixel con una
sequenza di bit, tale rappresentazione è nota come codifica bitmap.}

{}

\subparagraph{\texorpdfstring{{Vettoriali}}{Vettoriali}}\label{h.k06v7yackkng}

{Si affidano a equazioni matematiche per disegnare le immagini, per
questo è flessibile, le immagini possono essere ingrandite o
rimpicciolite senza compromettere la qualità.}

{Si possono convertire in jpg e png ma non viceversa.}

{}

\subparagraph{\texorpdfstring{{Compressione}}{Compressione}}\label{h.qulnftgky44t}

{Per risparmiare sulla dimensione si:}

\begin{itemize}
\tightlist
\item
  {usa una tavolozza (palette) per contenere i sottoinsiemi di colori
  rappresentabili;}
\item
  {usano tecniche (}{TIFF}{) di compressione cercando di raggruppare le
  aree che hanno caratteristiche comuni;}
\item
  {usano tecniche (}{GIF, JPG}{) di compressione che sfruttano la
  caratteristica dell'occhio umano di essere poco sensibile a lievi
  cambiamenti di colore in punti contigui, e quindi eliminano questi
  lievi cambiamenti appiattendo il colore dell'immagine.}
\end{itemize}

{}

{}

\paragraph{\texorpdfstring{{CODIFICA DEI
SUONI}}{CODIFICA DEI SUONI}}\label{h.gf0fe4asjno9}

{Per rappresentare le onde sonore che rappresentano il suono si usa la
quantizzazione e il campionamento:}

\begin{itemize}
\tightlist
\item
  {campionamento}{: scelta di istanti in cui considerare il valore del
  segnale;}
\item
  {quantizzazione}{: codifica dei campioni con un numero predefinito di
  bit.}
\end{itemize}

{}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image56.png}}}

{Questo è il suono in maniera analogica.}

{}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image60.png}}}

{Attraverso le tecniche precedentemente dette andiamo a individuare
diversi punti nel dominio del tempo e dell'ampiezza.}

{}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image45.png}}}

{Alla fine codifichiamo con una sequenza di bit il suono.}

{}

{}

{Per avere un segnale audio più simile all'originale dobbiamo avere
intervalli di campionamento più piccoli (in modo da perdere meno segnale
in mezzo a essi) e avere abbastanza bit nella fase di quantizzazione per
descrivere il suono; ovviamente maggiore accuratezza significa maggior
quantità di memoria occupata}{.}

{}

{}

{}

{}

{ALGEBRA BOOLEANA}

{È un sistema di logica matematica a due stati, dove le variabili
possono assumere solo due stati: vero (1) o falso (0).}

{}

{Si studia l'algebra booleana poiché le funzioni dell'algebra booleana
sono isomorfe ai circuiti digitali: un circuito digitale può essere
espresso tramite un'espressione booleana e viceversa.}

{}

{Una funzione booleana ha una o più variabili in input e fornisce
risultati che dipendono solo da queste variabili. Quindi una funzione
booleana con }{n }{variabili in input avrà solo
}\pandocbounded{\includegraphics[keepaspectratio]{images/image33.png}}{~combinazioni
possibili.}

{}

{Qualsiasi funzione può essere espressa con l'ausilio di }{AND}{, }{OR
}{e }{NOT }{detto ciò è possibile tradurre qualsiasi espressione in un
circuito.}

{}

{}

{}

{Qui i significati degli operatori:}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{AND} & {prodotto logico} & {=1 solo se tutti 1} \\
{OR} & {somma logica} & {=1 se almeno un 1} \\
{NOT} & {valore opposto} & {se A=1 allora Ā=0} \\
\end{longtable}

{}

\subparagraph{\texorpdfstring{{Teoremi}}{Teoremi}}\label{h.cdd6p5na2we6}

{Esistono proprietà per semplificare le espressioni booleane, ecco
quali:}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{Nome legge} & {Forma }{AND} & {Forma }{OR} \\
{Identità} & {1A = A} & {0 + A = A} \\
{Annullamento} & {0A = 0} & {1 + A = 1} \\
{Impotenza} & {AA = A} & {A + A = A} \\
{Inverso} & {AĀ = 0} & {A + Ā = 1} \\
{Commutativa} & {AB = BA} & {A + B = B + A} \\
{Associativa} & {(AB)C = A(BC)} & {(A + B) + C = A + (B + C)} \\
{Distributiva} & {A + BC = (A + B)(A + C)} & {A(B + C) = AB + AC} \\
{Assorbimento} & {A(A + B) = A} & {A + AB = A} \\
{De Morgan} &
{\pandocbounded{\includegraphics[keepaspectratio]{images/image49.png}}}
&
{\pandocbounded{\includegraphics[keepaspectratio]{images/image59.png}}} \\
{Assorbimento 2°} & {A + ĀB = A + B} &
{\textbackslash\textbackslash{}} \\
\end{longtable}

{}

{}

{Per }{verificare }{le leggi e teoremi bisogna creare tabelle di verità,
es di dimostrazione della 2° legge dell'assorbimento:}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{A} & {B} & {Ā AND B} & {Ā AND B + A} & {~A + B} \\
{0} & {0} & {0} & {0} & {0} \\
{0} & {1} & {1} & {1} & {1} \\
{1} & {0} & {0} & {1} & {1} \\
{1} & {1} & {0} & {1} & {1} \\
\end{longtable}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
}{↑ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~↑}

{~~~~~~~~~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ }{~ ~Essendo queste due
parti uguali il teorema è verificato}

\subparagraph{\texorpdfstring{{Tabelle di
verità}}{Tabelle di verità}}\label{h.icokc53zhm1t}

{Con l'utilizzo delle tabelle di verità posso arrivare a una espressione
andando a individuare quali combinazioni con output 1 rappresentano quel
risultato.}

{Questo tipo di espressioni si chiamano in }{prima forma canonica,}{~per
arrivare a questa forma è necessario:}

\begin{enumerate}
\tightlist
\item
  {~Identificare le righe in output (}{V}{) con risultato 1;}
\item
  {~in queste righe scrivere la configurazione delle variabili che le
  definiscono (saranno in }{AND}{~tra loro);}
\item
  {collegare tutte le configurazioni con l'}{OR}{.}
\end{enumerate}

{Es:}

{}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{X} & {Y} & {Z} & {V} \\
{0} & {0} & {0} & {0} \\
{0} & {0} & {1} & {1} \\
{0} & {1} & {0} & {1} \\
{0} & {1} & {1} & {0} \\
{1} & {0} & {0} & {1} \\
{1} & {0} & {1} & {0} \\
{1} & {1} & {0} & {0} \\
{1} & {1} & {1} & {1} \\
\end{longtable}

{Le righe evidenziate sono quelle con risultato (}{V}{) 1, quindi quelle
che ci interessano. Ora andiamo a scrivere le loro configurazioni:}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image38.png}}}

{Riga 1 → ~ ~ ~ ~ ~ ~ }

{\pandocbounded{\includegraphics[keepaspectratio]{images/image39.png}}}

{Riga 2 →
}{\pandocbounded{\includegraphics[keepaspectratio]{images/image58.png}}}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~}{~Risultato finale
}{→
}{\pandocbounded{\includegraphics[keepaspectratio]{images/image52.png}}}

{Riga 4 →}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image40.png}}}

{Riga 7 → }

{}

{}

{Due funzioni con ugual output si dicono equivalenti, andare a
determinare la più semplice funzione booleana equivalente alla funzione
data facilita l'interpretazione della funzione stessa e permette di
semplificare anche i circuiti logici corrispondenti. }

{}

{}

{}

{ARCHITETTURA DEI CALCOLATORI}

{}

{Un calcolatore è un sistema composto da un numero elevato di
componenti, il modello base è rappresentato dalla macchina di Von
Neumann, composto da:}

\begin{itemize}
\tightlist
\item
  {CPU;}
\item
  {Memoria;}
\item
  {Periferiche;}
\item
  {Bus.}
\end{itemize}

{}

\paragraph{\texorpdfstring{{BUS}}{BUS}}\label{h.fz7s64nbviu}

{Gestito dalla CPU (master) e nessun'altra unità (slave) può accedervi
autonomamente. Permette la comunicazione tra periferiche, CPU, cache,
memoria, ecc.}

{I Bus possono essere:}

\begin{itemize}
\tightlist
\item
  {bus dati}{: costituiti da
  }\pandocbounded{\includegraphics[keepaspectratio]{images/image33.png}}{~linee
  fisiche, passano i dati I/O della CPU;}
\item
  {bus degli indirizzi}{: determina l'indirizzo di memoria dove si andrà
  a leggere o scrivere;}
\item
  {bus di controllo}{: indica cosa fare nell'indirizzo di memoria (
  andare a leggere o scrivere).}
\end{itemize}

{}

\paragraph{\texorpdfstring{{SCHEDA
MADRE}}{SCHEDA MADRE}}\label{h.1mrb27bttyum}

{Contiene l\textquotesingle alloggiamento CPU, i bus, i connettori di
memoria, i connettori I/O, ecc.}

{La scheda madre controlla un insieme di chip detti }{chipset}{.}

{Dentro la Motherboard sono presenti dei connettori PCI (Peripheral
Component Interconnect) dove è possibile posizionare schede specifiche
come la GPU o l\textquotesingle Ethernet card.}

{}

\paragraph{\texorpdfstring{{CPU}}{CPU}}\label{h.vzoath5w1tay}

{Il cuore operativo del calcolatore, può essere chiamato anche
processore o microprocessore, con il compito di eseguire i programmi
presenti in RAM andando a leggere le loro istruzioni in sequenza.}

{}

{È composta da:}

\begin{itemize}
\tightlist
\item
  {Unità di controllo}{: legge le istruzioni in RAM;}
\item
  {ALU}{: esegue le operazioni (AND, OR, \ldots) necessarie per
  l'esecuzione;}
\item
  {Registri}{: sono celle di memoria molto piccole dove si salvano
  temporaneamente i risultati delle operazioni, in oltre sono proprio i
  registri che determinano il tipo della CPU (32 o 64 bit).}
\end{itemize}

{Al momento non si va oltre i 64 bit per via dei problemi di
retrocompatibilità che ci potrebbero essere con i programmi scritti in
128 bit.}

{I registri di dividono in:}

\begin{itemize}
\tightlist
\item
  {PC }{(Program Counter): Conserva l'indirizzo di memoria della
  prossima istruzione da seguire;}
\item
  {~}{IR }{(Instruction Register) contiene copia della codifica
  dell'istruzione da eseguire;}
\item
  {MAR }{(Memory Address Register): contiene l'indirizzo di memoria dove
  bisogna leggere/scrivere.}
\item
  {MDR }{(Memory Data Register): contiene l\textquotesingle informazione
  appena letta in memoria;}
\item
  {PSW }{(Processor Status Word): indica in che stato è il programma.}
\end{itemize}

{}

{La CPU lavora in modo ciclico andando a ripetere le operazioni qui
sotto elencate fino alla fine dell'esecuzione:}

\begin{itemize}
\tightlist
\item
  {Caricamento }{(}{Fetch}{): acquisizione dalla memoria di
  un'istruzione del programma;}
\item
  {Decodifica }{(}{Decode}{): identificazione del tipo di operazione da
  eseguire;}
\item
  {Esecuzione }{(}{Execute}{): effettuazione delle operazioni
  corrispondenti all'istruzione.}
\end{itemize}

{}

{Il ciclo di esecuzione con le seguenti operazioni è:}

\begin{enumerate}
\tightlist
\item
  {Segnale di avvio: il }{PC}{~viene inizializzato con l'indirizzo della
  prima istruzione da eseguire ~{[} }{fatto una volta sola}{~{]};}
\item
  {la CPU imposta }{MAR}{~← }{PC}{;}
\item
  {viene selezionata la cella da leggere, il contenuto viene inviato sul
  bus;}
\item
  {la CPU imposta }{IR}{~← }{MAR}{;}
\item
  {la CPU incrementa il }{PC}{~in modo che punti alla prossima
  istruzione;}
\item
  {la CPU esamina il }{IR}{~e determina le operazioni da svolgere;}
\item
  {tutte le unità interessate all'esecuzione vengono comandate;}
\item
  {al fine del ciclo la CPU torna al punto }{2}{.}
\end{enumerate}

{}

{I colori dei numeri rappresentano le fasi di }{Fetch}{, }{Decode}{~e
}{Execute}{.}

{}

\subparagraph{\texorpdfstring{{Linguaggio macchina e
assembly}}{Linguaggio macchina e assembly}}\label{h.sh7t777cq3al}

{Il linguaggio macchina}{~è un linguaggio comprensibile direttamente dal
processore della macchina.}

{}

{}

{L'assembler }{invece è la versione simbolica del linguaggio macchina in
cui i nomi delle operazioni e degli operandi sono indicati con codici
simbolici; è usato per parlare direttamente con la macchina.}

{}

{Esempio programma assembler e traduzione in binario:}

{}

{X = Y + 2 ~→ ~LOAD ~ ~ Y, R1 ~}{carica Y in R (dove R è un indirizzo
interno al processore {[}cache{]})}

{~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ADD ~ ~ ~ 2, R1 }{~}{aggiunge 2 al contenuto di
R1}

{~~~~~~~~~~~~~~~~STORE ~R1, X ~}{scrive il contenuto di R1 in X (dove X,
così come Y, è un indirizzo di ~ ~ ~ ~ ~ ~ ~memoria)}

{}

{}

{Ogni operazione viene codificata (che è sempre un Word o multipli)
diversamente in base al formato stabilito dal costruttore dell'hardware,
esempio:}

{}

{}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{Codice operativo} & {Modo 1} & {Op1} & {Modo 2} & {Op2} \\
\end{longtable}

{}

{Dove:}

\begin{enumerate}
\tightlist
\item
  {Il }{codice operativo}{~{[} 4 bit {]}: indica la codifica
  dell'operazione da fare (es: ADD 0001, LOAD 0110, ecc);}
\item
  {Il }{Modo 1/Modo 2}{~{[} 2 bit {]}: indica a cosa si riferisce
  }{Op1/Op2 }{(es: se è 00 allora Op1/Op2 è un numero di registro o 01
  allora Op1/Op2 è un indirizzo, ecc);}
\item
  {I'}{Op1/Op2}{~{[} 12 bit {]}: è quel qualcosa indicato dal suo modo.}
\end{enumerate}

{}

{Quindi ora la traduzione del programma precedente in linguaggio
macchina sarà:}

{}

{Modi}{:}

\begin{itemize}
\tightlist
\item
  {00}{~= registro; ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
  ~ ~ ~ }
\item
  {01}{~= memoria;}
\item
  {10 }{= immediato (è un dato).}
\end{itemize}

{}

{Cod. operativi}{:}

\begin{itemize}
\tightlist
\item
  {ADD}{~= 0001;}
\item
  {LOAD}{~= 0110;}
\item
  {STORE}{~= 0111.}
\end{itemize}

{}

{Traduzione:}

{}

\begin{longtable}[]{@{}lllll@{}}
\toprule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
{0110} & {01} & {01101} & {00} & {00001 }{{[}*{]}} \\
{0001} & {10} & {00010} & {00} & {00001} \\
{0111} & {00} & {00001} & {01} & {11100} \\
\end{longtable}

{~Ogni riga della tabella equivale ad una riga istruzione del programma
precedente.}

{{[}*{]}}{~}{essendo questo R1 per tradurlo in binario prendiamo solo il
numero (1 in questo caso).}

{}

\subparagraph{\texorpdfstring{{ALU}}{ALU}}\label{h.deog4yrwexpa}

{Serve per effettuare operazioni di tipo aritmetico e logico booleano,
un bit di }

{ALU è così rappresentato:}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image61.jpg}}}

{per rappresentare operazioni con più bit ne metto uno dietro l'altra.}

{}

{Es:}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image42.jpg}}}

{Qui possiamo vedere una somma 01+01, ogni ALU fa l'operazione della
posizione corrispondente, in questo caso la 1° ALU farà l'operazione fra
i numeri della posizione 0 (1+1) invece la 2° quelli della posizione 1
(0+0).}

{}

\paragraph{\texorpdfstring{{PROCESSORE}}{PROCESSORE}}\label{h.7mqpsz31r6g}

{}

\subparagraph{\texorpdfstring{{Clock e
GHz}}{Clock e GHz}}\label{h.nvnfsnsklon8}

{L'esecuzione di ogni processo viene misurata in }{clock}{, cioè la
velocità del processore di eseguire operazioni.}

{L'esecuzione è sincrona, quindi prima di fare
l\textquotesingle operazione successiva è necessario finire la
precedente. Alla fine di ogni operazione c'è un }{tick}{,}{~}{misurato
in Hz (tick al secondo), che scandisce le varie istruzioni.}

{}

\subparagraph{\texorpdfstring{{CISC vs
RISC}}{CISC vs RISC}}\label{h.egnle06v88j6}

{Nel mondo informatico esistono 2 correnti di pensiero sull'utilizzo
della CPU:}

\begin{itemize}
\tightlist
\item
  {CISC}{: in questo caso si decide di dare al processore più operazioni
  possibili alla CPU anche a scapito di avere }{più cicli}{;}
\item
  {RISC}{: }{in questo caso si decide che per ogni ciclo viene eseguita
  una e una sola istruzione, quindi ci saranno }{più istruzioni}{.}
\end{itemize}

{}

{Nel }{RISC}{~tutte le istruzioni e le istruzioni macchina vengono
eseguite direttamente dall'hardware e viene utilizzato il pipelining e
parallelismo.}

{}

\subparagraph{\texorpdfstring{{Pipelining}}{Pipelining}}\label{h.2ewlbdtsj7xn}

{L'esecuzione di ogni istruzione viene suddivisa in più fasi (}{stadi}{)
dove ognuna delle quali viene gestita da un hardware dedicato.}

{Per far in modo che questo accada bisogna garantire che le istruzioni
non siano in conflitto (non }{d}{evono dipendere l'una dall'altra).}

\subparagraph{\texorpdfstring{{Parallelismo}}{Parallelismo}}\label{h.h00xa9xbp9lo}

{Ne esistono di 2 tipi:}

\begin{enumerate}
\tightlist
\item
  {a livello di istruzione}{: più istruzioni vengono eseguite
  contemporaneamente all'interno della stessa CPU tramite tecniche di
  pipelining e processori superscalari;}
\item
  {a livello di processore}{: più CPU cooperano per la soluzione dello
  stesso problema, andando però ad abbandonare il modello Neumann.}
\end{enumerate}

{}

\subparagraph{\texorpdfstring{{Prestazioni}}{Prestazioni}}\label{h.ui3rkpnxpgxd}

{Per calcolare il tempo di esecuzione abbiamo bisogno della seguente
formula:}

{}

\pandocbounded{\includegraphics[keepaspectratio]{images/image34.png}}

{dove:}

\begin{itemize}
\tightlist
\item
  {T}{clock }{: periodo di clock della macchina;}
\item
  \pandocbounded{\includegraphics[keepaspectratio]{images/image35.png}}{~:
  numero di clock per ogni istruzione di tipo i;}
\item
  \pandocbounded{\includegraphics[keepaspectratio]{images/image36.png}}{:
  numero di istruzioni di tipo i;}
\end{itemize}

{}

\paragraph{\texorpdfstring{{MEMORIE}}{MEMORIE}}\label{h.o8uhgciqzihu}

{È la capacità di memorizzare le informazioni del calcolatore, deve
essere veloce, capiente e persistente; per conciliare le diverse
caratteristiche esistono due categorie:}

\begin{itemize}
\tightlist
\item
  {memoria centrale }{( veloce ma non persistente, contiene i programmi
  in esecuzione);}
\item
  {memoria di massa}{~( più lenta ma capiente e persistente).}
\end{itemize}

\subparagraph{\texorpdfstring{{}}{}}\label{h.unadb7r3c9zi}

\subparagraph{\texorpdfstring{{Tecnologie e
struttura}}{Tecnologie e struttura}}\label{h.fpkrj3t3p047}

{Esistono diverse tecnologie usate ora e in passato per creare le
memorie:}

\begin{itemize}
\tightlist
\item
  {elettroniche }{{[} }{mem. centrale}{~{]}: veloci ma sempre
  alimentate, costo per bit elevato;}
\item
  {magnetiche}{~{[} }{mem. massa }{{]}: basso costo per bit ma non
  volatili, sono lente;}
\item
  {ottiche}{: riscrivibili e utili alla grossa distribuzione.}
\end{itemize}

{}

{La memoria centrale è strutturata in }{celle}{, successione ordinata di
elementi binari raggruppati in unità minime, e ogni cella ha un proprio
}{indirizzo }{( si parte dallo 0).}

{Con K bit posso avere
}\pandocbounded{\includegraphics[keepaspectratio]{images/image37.png}}{~celle.}

\subparagraph{\texorpdfstring{{Tipo di
accesso}}{Tipo di accesso}}\label{h.lnf87iy3mxkd}

{Esistono quattro modi per accedere ad una cella di memoria, ogni modo
dipende dal tipo di memoria:}

\begin{enumerate}
\tightlist
\item
  {accesso sequenziale {[} }{nastri }{{]}: prima di poter arrivare alla
  cella interessata devo leggere le celle precedenti;}
\item
  {accesso casuale {[} }{casuale }{{]}: il tempo di accesso è
  indipendente dalla posizione e costante per tutte le celle;}
\item
  {accesso misto {[} }{dischi }{{]}: si accede in prossimità del dato e
  si procede in modo sequenziale;}
\item
  {accesso associativo {[} }{cache }{{]}: le celle si selezionano in
  base al tipo di dato contenuto, si usa per permettere alla CPU di
  avere subito i dati di un determinato processo.}
\end{enumerate}

{}

{Si può accedere alla memoria centrale mediante il registro MAR e si
prelevano/scrivono dati tramite }{l'MDR}{~in base al segnale di
lettura/scrittura definito dal bus di controllo.}

{}

\subparagraph{\texorpdfstring{{RAM }{vs ROM}{~}{vs
Flash}}{RAM vs ROM~vs Flash}}\label{h.a2bwla9j1lhw}

{Memoria RAM}{~(Random Access Memory): ad accesso casuale realizzata
mediante circuiti a semiconduttori, di tipo volatile;}

{}

{Memoria ROM}{~(Read-Only Memory): non volatile, scritta al momento
della produzione e che non può essere cancellata. Contiene il BIOS;}

{}

{Memorie FLASH}{: elettroniche non volatili ma riscrivibili.}

{}

\subparagraph{\texorpdfstring{{Tipi di RAM
}}{Tipi di RAM }}\label{h.qi3warjf24pc}

{I chip di memoria non vengono venduti singolarmente ma sono normalmente
organizzati su schede stampate. I principali formati sono:}

{}

\begin{itemize}
\tightlist
\item
  {SIMM }{(Single Inline Memory Module) : utilizza moduli DRAM quindi
  immagazzina ogni bit in un diverso condensatore (acceso 0 altrimenti
  1), se il condensatore perde la carica, l\textquotesingle informazione
  è perduta;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {DIMM }{(Dual Inline Memory Module): utilizzano SDRAM e i connettori
  si trovano su entrambe i lati della scheda;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {~}{SO-DIMM}{~(Small Outline Dual In-line Memory Module): sono
  semplicemente più piccoli e costano di meno.}
\end{itemize}

{}

{Attualmente sul mercato esistono }{due tipi distinti}{~di RAM: quelle
di tipo }{SDR }{(Single Data Rate) e quelle }{DDR }{(Double Data Rate).
Quest'ultime (DDR) possono trasferire un byte sia sul fronte di salita
che su quello di discesa del clock (lavorano il doppio rispetto alle SDR
che fanno un'operazione a colpo di clock).}

{Le DDR sono arrivate alle Gen 5 e non sono retrocompatibili.}

{}

{}

{}

\subparagraph{\texorpdfstring{{Tipi di
ROM}}{Tipi di ROM}}\label{h.f4u4p197qkjx}

{Le ROM esistenti sono:}

\begin{itemize}
\tightlist
\item
  {ROM }{(Read Only Memory): uniche veramente di sola lettura;}
\item
  {PROM }{(Programmable Read Only Memory): programmabili una sola
  volta;}
\item
  {EPROM }{(Erasable Programmable Read Only Memory): riprogrammate con
  apparecchiature speciali;}
\item
  {EEPROM}{~(Electrically Erasable Programmable Read Only Memory).}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{Cache}}{Cache}}\label{h.di5gs987ivj2}

{Per ovviare al problema di aspettare che l'informazione arrivi dalla
memoria alla CPU si è creata una memoria super veloce vicina al
processore, denominata }{cache}{.}

{In questa memoria si caricano tutte quelle informazioni che la CPU avrà
bisogno per un determinato processo andando a vedere qual è l'ultima
cella utilizzata.}

{}

{Al momento ne esistono 3 livelli:}

{}

\begin{enumerate}
\tightlist
\item
  {L1 -- Cache di livello 1}{, fa fisicamente parte del chip del
  microprocessore. Molto piccola e molto veloce;}
\item
  {L2 -- Cache di livello 2}{, prima sulla scheda madre, adesso è nel
  core;}
\item
  {L3 -- Cache di livello 3}{, è completamente condivisa tra i core
  dell'elaboratore.}
\end{enumerate}

{}

\subparagraph{\texorpdfstring{{Memorie di
massa}}{Memorie di massa}}\label{h.nifrez2xausa}

{Nastri}

{Le prime memorie di massa create furono i nastri magnetici, permettono
solo accesso sequenziale ai dati e i dati vengono scritti
trasversalmente rispetto alla direzione.}

{}

{Floppy Disk}

{Il Floppy disk è stato il primo supporto magnetico con accesso diretto
ai dati. I floppy disk possono memorizzare fino a 1,44 MB, il
funzionamento è simile a quello dell'hard disk.}

{Dischi magnetici (HDD)}

{Dispositivo elettromeccanico per la conservazione di informazioni sotto
forma magnetica, su }{supporto rotante}{~a forma di piatto su cui
agiscono delle testine di lettura/scrittura.}

{La }{testina }{contenente un induttore ed è sospesa sopra la superficie
e viene sostenuta da un cuscino d'aria.}

{È possibile }{partizionare }{il disco per dividere un unico HDD in più
parti logiche.}

{}

{Un hard disk è strutturato}{~per registrare dati su cilindri, }{tracce
}{(sequenza circolare di bit) e }{settori }{(composto da preambolo, dati
e codice errore)}{.}

{}

{Per scrivere e leggere si usano due testine diverse}{, in }{scrittura
}{quando la corrente negativa o positiva passa attraverso la testina,
viene magnetizzata la superficie sotto la testina, invece in
}{lettura}{~quando una testina passa sopra un'area magnetizzata viene
indotta una corrente positiva o negativa nella testina: questo permette
di rileggere i bit memorizzati precedentemente.}

{}

{La capacità di memorizzazione}{~dipende principalmente dalla densità di
registrazione, quindi quante informazioni possono essere immagazzinate
in una determinata area.}

{}

{Le prestazioni}{~degli hard disk dipendono da:}

{}

\begin{itemize}
\tightlist
\item
  {Seek time}{: è il tempo necessario per spostare le testine sul
  cilindro desiderato;}
\item
  {Latency time}{: il tempo necessario affinché il settore interessato
  passi sotto la testina (definito dalla velocità di rotazione del
  disco).}
\end{itemize}

{}

{Dischi a stato solido (SDD)}

{Non hanno veramente dei dischi fisici ma sono basati su }{componenti
elettronici }{composti da chip }{NAND}{, cioè insieme di celle che
includono un transistor MOSFET capace di memorizzare in una sola cella
più combinazioni di 0 e 1 (e non solo true/false, 0/1) questo è
possibile guardando la tensione elettrica data ad una cella, per questo
sono molto veloci ma la loro capacità di tenere informazioni scende con
il tempo.}

{}

{}

{Le memorie sono }{classificate }{da quanti valori di bit possono essere
conservati, alcuni esempi sono:}

{}

\begin{itemize}
\tightlist
\item
  {~SLC (single level cell, un bit): un solo bit per cella (0/1);}
\item
  {~MLC (multi-level cell, due bit): 2 bit per cella (00/01/10/11);}
\item
  {TLC (triple-level cell, tre bit): 3 bit per cella
  (000/001/010/011/100/\ldots);}
\item
  {QLC (quad-level cell, quattro bit) 4 bit per cella
  (0000/0001/0010/0011/0100/\ldots).}
\end{itemize}

{}

{Più si aumentano le combinazioni più il range di Volt necessari per
rappresentare i valori si abbassa e quindi è più possibile, con il
passare del tempo, che i valori diventino meno precisi.}

{}

{Dischi ottici (CD)}

{Informazioni }{codificate }{per mezzo di }{fori }{(Pit) alternati con
}{zone piane}{~(Land) lungo un'unica spirale. Un passaggio PitLand o
Land-Pit codifica un 1 invece l'assenza di variazioni codifica lo 0.}

{}

{La }{lettura }{avviene a tramite un raggio laser che viene riflesso
diversamente al passaggio su pit e land. }

{}

{Lungo la spirale }{i dati sono memorizzati con la stessa densità}{,
quindi il CD ruota con velocità angolare variabile per mantenere la
medesima velocità lineare nelle diverse aree del CD.}

{}

{I dischi possono suddividersi in:}

{}

\begin{itemize}
\tightlist
\item
  {CD-ROM }{(Compact Disc-Read Only Memory): utilizzano la tecnologia
  dei CD per memorizzare dati informatici, ogni byte viene }{codificato
  da un simbolo di 14 bit}{, raggruppati poi in }{Frame}{(gruppo di 42
  simboli) e a loro volta in Settori (gruppo di 98 frame);}
\item
  {CD-R}{~(Compact Disc-Recordable): sono registrabili dagli utenti
  senza l'utilizzo dello stampo, ~la riflettività di pit e land viene
  ottenuta ``bruciando'', tramite un raggio laser, uno strato di
  materiale colorato inserito tra il policarbonato e lo strato
  riflettente;}
\item
  {CD-RW}{: dischi riscrivibili molto simili come concetto a quelli
  registrabili ma possiedono la possibilità di essere cancellati;}
\item
  {DVD }{(Digital Video Disk o Digital Versatile Disk): Pit più piccoli,
  spirale più serrata e raggio laser rosso. Più capienti, veloci e con
  la possibilità di scrivere su due strati (tecnologia con doppio
  strato).}
\end{itemize}

{Altri standard DVD: DVD-R, DVD+R e DVD-RAM.}

{}

{}

{SISTEMI OPERATIVI}

\paragraph{\texorpdfstring{{DEFINIZIONI}}{DEFINIZIONI}}\label{h.mzj0febxrs32}

{Un}{~sistema operativo}{~è un }{insieme di programmi}{~(software) che
}{gestiscono l'hardware}{, fornendo una }{piattaforma ai
programmi}{~applicativi e agisce da intermediario tra l'utente e la
struttura fisica del calcolatore.}

{Il S.O. }{si colloca}{~fra l'hardware e il software o comunque ciò che
vede e tocca l'utente, ha il compito di assegnare le risorse e decidere
chi userà la CPU e per quanto tempo.}

{Un'altro compito del S.O. è quello di generalizzare le caratteristiche
fisiche fino a renderle virtuali, andando anche a superare i limiti
fisici di certe parti del calcolatore.}

{}

{Un altro modo di definire il sistema operativo è quello di considerarlo
come quello strato di software che fornisce a programmi e applicazioni
una macchina virtuale attraverso la quale accedere alle risorse hardware
del computer. Infatti fornisce agli sviluppatori di software la
possibilità di usare API semplici che nascondono le caratteristiche
dell'hardware.}

{}

\paragraph{\texorpdfstring{{STORIA}}{STORIA}}\label{h.qmhzpkecz7zn}

{Dal primo S.O. ad adesso sono passati molti anni, ecco come vengono
divisi:}

{}

\begin{enumerate}
\tightlist
\item
  {1° Gen {[}45-55{]}}{: in questo periodo venivano usate macchine a
  valvole gestite con codici scritti su schede perforate, ancora non
  esiste il concetto di Sistema Operativo ed ogni programma era
  auto-contenuto;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {2° Gen {[}55-65{]}}{: i transistor vengono implementati nei computer
  e vengono identificati due nuovi ruoli:}
\end{enumerate}

\begin{itemize}
\tightlist
\item
  {Programmatore (con schede perforate e assembly);}
\item
  {Operatore (che esegue il job o programma). }
\end{itemize}

{Al momento i sistemi operativi sono a lotti o batch, c'è
l\textquotesingle assenza di interazione da parte dell'utente e i
~programmi con esigenze simili ( job) vengono raggruppati in lotti ed
eseguiti in modo sequenziale (viene fatto un job alla volta);}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {3° Gen {[}65-80{]}}{: nascono i circuiti integrati, la programmazione
  diventa ad alto livello, i S.O. diventano multitasking e con il
  time-sharing (l'esecuzione della CPU viene suddivisa in quanti di
  tempo assegnati a turno ai diversi programmi). }
\end{enumerate}

{In questo periodo il MIT realizza il CTSS (Compatible Time Sharing
System) introducendo la multiprogrammazione (più programmi in memoria si
alternano nell'uso della CPU) e il time-sharing (ripartizione del tempo
di CPU tra tutti i processi in memoria e attivi tramiti porzioni di
tempo delle time slice). }

{}

{Inoltre ecco alcune date importanti in questa generazione:}

\begin{itemize}
\tightlist
\item
  {1969}{: nasce }{UNIX}{;}
\item
  {1980}{: ~sviluppato il sistema operativo }{QDOS}{;}
\item
  {1981}{: la Microsoft di Bill Gates, acquista i diritti del QDOS e lo
  rivende, con il nome di }{MS-DOS}{~(}{IBM lancia il primo PC}{);}
\item
  {1984}{: rilasciato l'}{Apple Macintosh}{, con il sistema operativo a
  interfaccia grafica }{System 1.0;}
\item
  {1985}{: la Microsoft lancia la prima versione di Windows, il
  }{Windows 1.0}{;}
\item
  {1991}{: nasce }{Linux}{.}
\end{itemize}

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {4° Gen}{: L'attenzione si sposta sull'utente e sulle sue esigenze:}
\end{enumerate}

\begin{itemize}
\tightlist
\item
  {Interfaccia grafica;}
\item
  {Interattività;}
\item
  {Collegamento in rete;}
\end{itemize}

{~ ~ Nasce il Personal Computer.}

{}

\paragraph{\texorpdfstring{{SERVIZI}}{SERVIZI}}\label{h.awli49g8b7vn}

{I principali servizi che un S.O. offre sono:}

{}

\begin{itemize}
\tightlist
\item
  {Interfaccia utente}{: che può essere a riga di comando, più veloce ma
  meno intuitiva, oppure GUI quindi con grafica.}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Esecuzione di programmi}{: il sistema deve poter }{caricare, eseguire
  e terminare}{~senza problemi e crash un qualsiasi processo.}
\end{itemize}

{Il processo è formato da:}

\begin{enumerate}
\tightlist
\item
  {Algoritmo: sequenza di passi che consentono di risolvere un
  problema;}
\item
  {Programma: descrizione di un algoritmo tramite un linguaggio che ne
  rende possibile l'esecuzione da parte di un processore ;}
\item
  {Evento: esecuzione di una delle istruzioni da parte del processore;}
\item
  {Processo: sequenza di eventi prodotti da un processore
  nell'esecuzione di un programma.}
\end{enumerate}

{Al giorno d'oggi tutti i S.O. operativi sono multitasking, cioè possono
eseguire più programmi contemporaneamente, nei sistemi con un solo
processore l\textquotesingle esecuzione contemporanea dei processi è
virtuale.}

{Un processo può essere:}

\begin{itemize}
\tightlist
\item
  {Running}{: le sue istruzioni sono eseguite da un processore (solo un
  programma può esserlo);}
\item
  {Ready}{: il processo è in attesa che le sue istruzioni vengano
  eseguite da un processore;}
\item
  {Waiting}{: il processo è in attesa di un evento.}
\end{itemize}

{Oltre a questi stati un processo può essere }{new}{~e }{terminated}{.}

{}

\begin{itemize}
\tightlist
\item
  {Comunicazione tra i processi}{: il S.O. deve fornire supporto allo
  scambio di informazioni tra processi è lo può fare allocando spazi di
  memoria in cui i processi condividono i dati (Memoria condivisa)
  oppure via messaggi. Qualunque soluzione adottata supporta la
  sincronizzazione.}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Gestione memoria}{: il S.O. crea una macchina virtuale che consente
  di far riferimento a spazi di indirizzi virtuali, impedisce ad un
  processo di accedere a locazioni di memoria non autorizzate e ignora
  se il programma e i suoi dati siano }{fisicamente}{~residenti in
  memoria centrale o su memoria di massa.}
\end{itemize}

{Questa macchina virtuale gestisce i }{file system }{cioè quel
componente che permette al S.O. di:}

\begin{itemize}
\tightlist
\item
  {eseguire operazioni di lettura/scrittura da parte di programmi;}
\item
  {creare, cancellare ed eseguire file;}
\item
  {proteggere.}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Gestione delle periferiche}{: la macchina virtuale creata dal S.O.
  dispone delle proprie periferiche }{dediche}{~ad ogni processo che
  mascherano le caratteristiche fisiche delle vere periferiche.}
\end{itemize}

{Il S.O. deve fornire strumenti adeguati alla gestione dell'I/O da parte
dei programmi con protezione e condivisione, quest'ultimo attraverso lo
}{Spooling}{~(spostamento di dati in un buffer in attesa di essere
smistati verso il dispositivo o l\textquotesingle applicativo che li
deve elaborare).}

{}

\paragraph{\texorpdfstring{{API e System
call}}{API e System call}}\label{h.a2bq0ju8xrt6}

{Le chiamate a sistema (system call), costituiscono l'interfaccia tra il
processo utente e il sistema operativo. Il programmatore usa le API che
specificano le funzioni a disposizione dei programmatori, nonché
parametri da usare e valori restituiti.}

{Per funzionare quando il processo chiama il S.O. si sospende in attesa
che questo termini le attività richieste (}{return from system call}{),
se l'attività richiede tempo, il processo può entrare in stato di wait
ed essere riattivato solo all'arrivo di un opportuno interrupt.}

{}

\paragraph{\texorpdfstring{{CLASSIFICAZIONE
S.O.}}{CLASSIFICAZIONE S.O.}}\label{h.2fcqtnu96k1h}

{I sistemi operativi vengono classificati come:}

{}

\begin{itemize}
\tightlist
\item
  {Real time}{: tutti quei sistemi di guida autonoma, }{biomedicali}{~o
  militari;}
\item
  {Singolo utente -- singolo programma}{: come MS-DOS;}
\item
  {Singolo utente -- }{multiprogramma}{:}{~come Windows o Mac OS;}
\item
  {Multiutente}{: come Windows Server, Unix o Linux;}
\item
  {Multiprocessore}{: come Windows NT, Solaris, Digital UNIX, OS/2 e
  Linux.}
\end{itemize}

{}

\paragraph{\texorpdfstring{{STRUTTURA
S.O.}}{STRUTTURA S.O.}}\label{h.mf59peh2dtqj}

{Alcuni S.O. meno recenti non hanno una struttura ben definita e sono
realizzati con obiettivi legati più che altro alle dimensioni e
all'efficienza.}

{Al contrario i S.O. più recenti sono divisi in moduli con funzioni ben
specifiche.}

\subparagraph{\texorpdfstring{{Sistemi
stratificati}}{Sistemi stratificati}}\label{h.akr3lkhw2anm}

{I sistemi operativi possono essere suddivisi in parti di codice più
piccoli e più gestibili, per far ciò si ricorre al metodo stratificato
che prevede di suddividere il SO in un certo numero di livelli o strato,
dove ogni strato offre servizi a quello superiore e usa quelli dello
strato inferiore.}

{Questo tipo di progettazione permette la definizione più
}{marcata}{~degli stati e dei servizi ed un'efficienza complessiva del
sistema; lo strato più interno è il }{kernel}{.}

\subparagraph{\texorpdfstring{{Kernel}}{Kernel}}\label{h.rvb59j9w1dsu}

{Il kernel è una parte del S.O. che fornisce alle applicazioni l'accesso
sicuro e condiviso all'hardware ma non contiene applicazioni o processi
( es: interfaccia utente)}

\subparagraph{\texorpdfstring{{Kernel
monolitico}}{Kernel monolitico}}\label{h.sawohzopwcyt}

{In questo modello c'è una }{completa astrazione
dell\textquotesingle hardware sottostante,}{~una stretta integrazione
interna dei componenti rende un buon kernel monolitico }{estremamente
efficiente}{; in questo caso però non è possibile aggiungere un nuovo
dispositivo hardware senza aggiungere il relativo modulo al kernel,
operazione che richiede la ricompilazione del kernel.}

{}

\paragraph{\texorpdfstring{{PROCESSI}}{PROCESSI}}\label{h.cmpk8qf0651u}

{Il processo è un programma in esecuzione, è un'entità attiva e può
generare altri processi. }

{Esso è l'unità di lavoro del sistema in esecuzione, e il sistema stesso
è un insieme di processi.}

{Nel processo si distinguono diverse parti:}

{}

\begin{itemize}
\tightlist
\item
  {Algoritmo}{: sequenza di passi che consentono di risolvere un
  problema;}
\item
  {Programma}{: descrizione di un algoritmo tramite un linguaggio che ne
  rende possibile l'esecuzione da parte di un processore;}
\item
  {Processo}{: sequenza di eventi prodotti da un processore
  nell'esecuzione di una istanza di programma.}
\end{itemize}

\subparagraph{\texorpdfstring{{Time
sharing}}{Time sharing}}\label{h.s5q4kh6b1az8}

{Per permettere l'esecuzione di più processi allo stesso tempo in
computer con un singolo processore si utilizza la tecnica del }{time
sharing}{~che divide l'utilizzo della CPU fra tutti i processi dando a
ciascuno un margine di tempo detto }{time slice}{.}

{Questo periodo di tempo è velocissimo per non far percepire
rallentamenti all'utente, ogni programma ha più time slice e aspetta il
suo turno per utilizzare la CPU.}

{}

{}

{}

\subparagraph{\texorpdfstring{{Rappresentazione in
memoria}}{Rappresentazione in memoria}}\label{h.wxx5dyg8eang}

{Lo spazio di memoria di un processo può essere diviso in sezioni: }

{}

\begin{itemize}
\tightlist
\item
  {Codice}{: contiene il codice del programma (sola lettura);}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Dati}{: in questa sezione vengono immagazzinate le variabili statiche
  (la sua dimensione può essere modificata).}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Stack}{: usato per allocare dinamicamente le variabili locali usate
  nelle funzioni, per passare parametri alle funzioni e per restituire
  valori dalle stesse;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Heap}{: memoria allocata dinamicamente durante l'esecuzione del
  programma.}
\end{itemize}

{}

{Il S.O. rappresenta ogni processo con un }{PCB}{~(Process Control
Block) una sorta di ``fotografia'' del processo nel momento in cui
smette di usare la CPU nel suo time slice; il PCB è necessario per
permettere al processo di riprendere esattamente dal momento del suo
blocco. Il PCB salva:}

\begin{itemize}
\tightlist
\item
  {Stato del processo;}
\item
  {Istruzione successiva;}
\item
  {Registri della CPU;}
\item
  {Informazioni dello scheduling;}
\item
  {\ldots{}}
\end{itemize}

{}

{Il sistema operativo ha il compito di evitare i }{deadlock}{~cioè
quando un processo si blocca e a sua volta blocca altri in maniera
irreversibile, ciò accade spesso quando più processi cercano di
utilizzare le stesse risorse andando in conflitto.}

\subparagraph{\texorpdfstring{{Stati del
processo}}{Stati del processo}}\label{h.iqsfilp0d9ux}

{Durante tutto il suo ciclo di vita il processo può avere 5 stati:}

{}

\begin{enumerate}
\tightlist
\item
  {New}{: il processo è appena stato creato;}
\item
  {Ready}{: il processo adesso aspetta il suo turno per essere assegnato
  ad un processore;}
\item
  {Running}{: il processo sta utilizzando un processore;}
\item
  {Waiting}{: il processo è in attesa di qualcosa, ciò può accadere se
  esso aspetta un segnale input dall'utente;}
\item
  {Terminated}{: il processo ha finito il suo ciclo di vita.}
\end{enumerate}

\subparagraph{\texorpdfstring{{Tipi di
processi}}{Tipi di processi}}\label{h.vukodmm6xr7k}

{I processi si dividono in due categorie:}

{}

\begin{itemize}
\tightlist
\item
  {I/O-Bound}{: si differenziano per la poca esecuzione di calcoli,
  infatti in questi processi stanno per la maggior parte del tempo nello
  stato di }{waiting}{, eseguendo istruzioni I/O;}
\item
  {CPU-Bound}{: spendono la maggior parte del tempo in computazione a
  fronte di pochissime operazioni di I/O, passano spesso dallo stato di
  }{ready }{a quello di }{running}{.}
\end{itemize}

\subparagraph{\texorpdfstring{{Context
Switch}}{Context Switch}}\label{h.9zgszgeo657u}

{Quando la CPU cambia il processo in esecuzione, il sistema deve salvare
lo stato del vecchio processo, determinare quale sia il nuovo processo
da eseguire, caricare lo stato del nuovo processo e avviarlo. Queste
attività prendono il nome di }{Context Switching}{, il tempo per farli
deve essere il più piccolo possibile.}

{Processi e sottoprocessi}

{Tra le possibili cause di context switch può esserci la creazione di un
processo, il processo che crea altri processi è detto }{padre}{~quelli
creati sono detti }{figli}{.}

{In questo caso si crea una struttura ad albero dove la radice è il
processo antenato di quella dopo.}

{Resource sharing}

{Il processo padre può:}

\begin{itemize}
\tightlist
\item
  {condivide con il figlio le proprie risorse (e viceversa);}
\item
  {condividere un sottoinsieme con il figlio;}
\item
  {non condividere risorse con il figlio.}
\end{itemize}

{~}{Esecuzione}

{Esistono due possibili strade quando si parla di esecuzione fra
processi e sottoprocessi:}

\begin{enumerate}
\tightlist
\item
  {padre e figlio eseguono concorrentemente;}
\item
  {Il padre attende che il figlio termini.}
\end{enumerate}

{Spazio degli indirizzi }

{Quando bisogna salvare in memoria i processi e sottoprocessi il S.O.
può:}

\begin{itemize}
\tightlist
\item
  {salvare il figlio come duplicato del padre;}
\item
  {usare il figlio per caricare un programma.}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{Terminazione
processo}}{Terminazione processo}}\label{h.qkwtrrzfxaut}

{Con l'istruzione }{exit}{~il processo chiede al S.O. di terminare, in
questo modo tutte le risorse del processo vengono deallocate.}

{}

{Nel caso di processi padre e processi figli è il padre a decidere
quando }{terminarli}{~(}{abord}{),}{~ma per farlo deve conoscerne
l'identità.}

{Il padre decide di terminare il figlio se:}

\begin{itemize}
\tightlist
\item
  {il figlio ha ecceduto nell'uso delle risorse;}
\item
  {il compito assegnato al figlio non è più richiesto;}
\item
  {il ~padre termina e quindi il figlio non ha più ragione di esistere
  (}{terminazione a cascata}{).}
\end{itemize}

\subparagraph{\texorpdfstring{{Processi
cooperanti}}{Processi cooperanti}}\label{h.3zgn3syfyvga}

{I processi concorrenti possono essere:}

{}

\begin{itemize}
\tightlist
\item
  {Indipendenti}{: la loro esecuzione non può influire né essere
  influenzata da altri processi.}
\item
  {Cooperanti}{: l'esecuzione di un processo influisce su quella degli
  altri. }
\end{itemize}

{}

{Con la cooperazione si permette l'}{information sharing}{~(utile per
consentire all'utente la condivisione delle risorse), la }{speed-up
nella computazione}{, la }{modularità}{~(scomporre le funzionalità di un
sistema in più parti) e infine la }{convenienza}{~di offrire più
funzionalità in modo contemporaneo.}

{}

{Per cooperare si utilizza la modalità dei }{sistemi a }{memoria
condivisa}{, in questo modo i processi condividono una parte di memoria,
solitamente il S.O. impedisce accessi alla memoria di altri processi a
meno che questo non avvenga entro precise modalità predefinite dal
}{S.O. stesso}{.}

\subparagraph{\texorpdfstring{{Producer \&
Consumer}}{Producer \& Consumer}}\label{h.ggi02vb437wk}

{Un paradigma per la programmazione concorrente è il problema del
produttore/consumatore, dove nascono due scenari:}

\begin{enumerate}
\tightlist
\item
  {unbounded-buffer}{: dove c'è il buffer senza limiti;}
\item
  {bounded-buffer:}{~il buffer ha una dimensione limitata, per questo il
  }{consumatore}{~deve attendere se il vettore è vuoto o il
  }{produttore}{~deve attendere se il vettore è pieno.}
\end{enumerate}

{}

{}

{Per questo il }{buffer}{~deve essere condiviso dal produttore e dal
consumatore, è fornito da S.O. o essere uno spazio di memoria
condiviso.}

\subparagraph{\texorpdfstring{{Condivisione tramite
messaggi}}{Condivisione tramite messaggi}}\label{h.i6jc8w97gtf3}

{Esiste uno strumento che consente la comunicazione fra processi e la
loro sincronizzazione senza memoria, è chiamato }{Message Passing}{,
consiste nell'invio di messaggi (}{send}{) e la ricezione (}{receive}{)
tra processi.}

{Per farlo i due processi devono instaurare una comunicazione fra loro
che può avvenire in modo fisico, tramite bus, o in via logica.}

{La comunicazione può essere:}

\begin{itemize}
\tightlist
\item
  {Sincrona o asincrona: dove il processo si può bloccare o no durante
  la comunicazione;}
\item
  {Diretta o indiretta: la comunicazione tra processi avviene processo a
  processo o tramite mailbox;}
\item
  {Buffering;}
\end{itemize}

{}

\paragraph{\texorpdfstring{{THREAD}}{THREAD}}\label{h.5tai6lrtweui}

{Fino ad ora ~abbiamo considerato il processo come un programma in
esecuzione in un unico flusso di controllo, ma al giorno d'oggi i S.O.
consentono di eseguire processi attraverso più flussi di controllo, che
sono solitamente chiamati thread.}

{}

{I thread sono l'unità base dell'uso della CPU}

{}

{Nello stesso processo possono nascere più thread, per questo si parla
di multithreading, un processo tradizionale è detto processo pesante
perché ha }{un'unico}{~thread.}

\subparagraph{\texorpdfstring{{Benefici}}{Benefici}}\label{h.r2y8qpbi42ch}

{Con i thread e il multithreading abbiamo una responsiveness (tempo di
risposta) più alta. }

{Grazie alla definizione di thread, nello stesso task è possibile il
resource sharing , in modo da permettere all'applicazione di avere più
thread che operano su uno stesso spazio di indirizzi; anche per questo è
più facile creare e distruggere thread.}

{}

{}

\paragraph{\texorpdfstring{{SCHEDULING}}{SCHEDULING}}\label{h.jr05k81i48zz}

{Lo scheduler ~della CPU è il meccanismo sul quale sono basati i sistemi
che supportano la multiprogrammazione andando a massimizzare il tempo
d'uso della CPU.}

{In questi sistemi le prestazioni sono influenzate dal tipo di attività
dei processi, in un processo di tipo I/O bound i cicli di }{CPU burst
(momento dove il processo lavora in CPU)}{~sono molti ma molto brevi
perché interrotti da I/O; invece in un processo di tipo CPU bound i
cicli di CPU burst sono meno ma più duraturi.}

{}

{I cicli CPU burst sono solitamente molto brevi}

{~per evitare rallentamenti.}

\subparagraph{\texorpdfstring{{Ready
queue}}{Ready queue}}\label{h.p5wn5yds5b2}

{Lo scheduler a breve termine (altro nome della multiprogrammazione)
lavora nella ready queue,una struttura dati dello scheduler dove sono
parcheggiati tutti i processi nello stato di ready.}

{Quando un nuovo processo entra nella ready queue si possono adottare
due differenti politiche: }

\begin{itemize}
\tightlist
\item
  {Preemptive scheduling: il processo che arriva ha una priorità, se è
  maggiore rispetto a quella del processo in esecuzione lo spodesta.}
\item
  {Non preemptive: la CPU rimane al processo in esecuzione fino alla
  fine.}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{Dispatcher}}{Dispatcher}}\label{h.w8478h2x9e96}

{È quella parte del S.O. che passa effettivamente il controllo della CPU
al processo selezionato dallo scheduler; deve eseguire lo switching
(ripristino del contesto del processo) ~e il riavvio dell'esecuzione.}

{}

\subparagraph{\texorpdfstring{{Algoritmi di
scheduling}}{Algoritmi di scheduling}}\label{h.sibnvtmdopjy}

{Il confronto tra algoritmi avviene in base:}

{}

\begin{enumerate}
\tightlist
\item
  {Utilizzo di CPU;}
\item
  {Throughput (numero di processi completati nell'unità di tempo);}
\item
  {Tempo di turnaround (tempo complessivamente necessario per eseguire
  il processo);}
\item
  {Tempo di attesa(trascorso dal processo nella coda dei ready);}
\item
  {Tempo di risposta.}
\end{enumerate}

{}

{}

{FCFS/FIFO}

{Il primo processo ad arrivare sarà il primo a finire, quando il
processo entra in coda il suo PCB viene messo in fondo.}

{Non è molto efficace perché un ~solo processo molto lungo può bloccare
molti processi che avrebbero eseguito velocemente (effetto convoglio).}

{}

{SJF}

{L'algoritmo Shortest Job First nasce con l'idea di privilegiare i
processi più corti. In caso il CPU burst sia uguale (durano ugual tempo)
si utilizza la tecnica FIFO.}

{}

{Questo algoritmo è effetto da starvation, quindi è possibile che i
processi molto lunghi non avvengano mai; esistono due modalità:}

{}

\begin{itemize}
\tightlist
\item
  {Non preemptive: quando un processo ottiene la CPU non viene
  interrotto;}
\end{itemize}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image48.png}}}

{esempio}

{}

{}

{}

{}

{}

{}

\begin{itemize}
\tightlist
\item
  {Preemptive: quando arriva un nuovo processo con CPU burst minore del
  CPU burst rimanente per il processo correntemente in esecuzione, il
  nuovo processo prende la CPU.}
\end{itemize}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image51.png}}}

{esempio}

{}

{}

{Priority scheduling}

{Si usa un valore numerico per indicare quale processo fare prima, più
il valore è alto più velocemente deve accedere alla CPU; più il tempo di
attesa in coda aumenta per un processo più il valore della sua priorità
aumenta (aging).}

{Round Robin}

{Unico algoritmo visto fino ad ora adatto ai S.O. time sharing, è una
variante del FCFS.}

{Utilizza uno scheduler chiamato Round Robin dove la coda è gestita in
maniera circolare, dove ogni volta che un processo viene messo in
esecuzione, lo scheduler imposta un timer che ne limita il tempo di
esecuzione.}

{Code multiple}

{Questo algoritmo gestisce i processi di classe diverse; divisi in
foreground, quelli interattivi, e background (quelli batch).}

{In questo algoritmo la ~ready queue viene partizionata in più code
separate e ciascun processo è associato in modo statico ad una coda.}

{La particolarità è l'utilizzo di scheduler diversi per cose diverse, ad
esempio RR sui processi foreground e FCFS per i processi in background.}

{}

{Per sapere da che }{coda}{~prelevo il prossimo processo da eseguire si
utilizzano scheduling tra le code che possono essere:}

{}

\begin{itemize}
\tightlist
\item
  {il non eseguire nessun processo della coda n se la coda n-1 non è
  vuota;}
\item
  {il definire dei quanti di tempo tra le code.}
\end{itemize}

{}

{Code multiple con feedback}

{Nella code multiple normale ogni processo rimane sempre nella stessa
coda, si può invece fare in modo che i processi mutino dinamicamente
posizione, ad esempio in funzione del CPU burst che hanno.}

{Andando a creare un struttura dove ~la coda di livello più alto è
quella che contiene i processi con CPU burst inferiore.}

{}

{Un processo viene inserito inizialmente nella coda più veloce per poi
retrocedere ~alla coda di livello inferiore quando non termina nel time
slice di quella coda.}

{}

{}

\paragraph{\texorpdfstring{{CONCORRENZA}}{CONCORRENZA}}\label{h.uz2cn3bgavaa}

{I processi possono essere eseguiti in modo:}

{}

\begin{itemize}
\tightlist
\item
  {Concorrente: competono per l'accesso ad una risorsa;}
\item
  {Parallelo: sono eseguiti su diverse unità funzionali.}
\end{itemize}

{}

{Qualunque sia l'esecuzione si generano problematiche
sull\textquotesingle integrità dei dati condivisi, con il }{race
condition}{~si}{~indica l'accesso a dati senza sincronizzazione e
controlli}{; per ovviare al problema si utilizzano parti di codice dette
atomiche.}

{}

\subparagraph{\texorpdfstring{{Critical
section}}{Critical section}}\label{h.9lse25s7e9of}

{È una parte di codice, costruita attorno alle variabili condivise, che
avranno un unico utilizzatore andando a scongiurare l'inconsistenza.}

{}

{Una Sezione Critica (CS) è una porzione di codice in cui i dati
condivisi da processi cooperanti possono essere manipolati }

{}

{La CS è preceduta da una sezione di ingresso e una di uscita.}

{Ogni thread ha una }{critical}{~}{section}{~in cui accedere per
modificare variabili condivise, l\textquotesingle esecuzione di queste
parti deve garantire il MUTEX (mutua esclusione, è un meccanismo di
blocco).}

{Il Thread non deve rimanere bloccato per sempre (Liveness), per questo
tramite il Bounded waiting, al thread può essere bloccato l'accesso solo
un numero limitato di volte.}

{}

\subparagraph{\texorpdfstring{{Test and
Set}}{Test and Set}}\label{h.msqqq0yz6w3h}

{In questa modalità si utilizzano variabili do lock, allocate
all'interno della memoria condivisa che funziona come lucchetto; se per
esempio questa cella ha valore 0 allora è possibile accedere alla
variabile altrimenti no.}

{Il valore viene settato dal processo che utilizza la risorsa nella CS.}

{}

{Un problema di questa modalità è l'interruzione forzata tramite
interrupt dei processi che aspettano la variabile in lock; per ovviare è
stato creato il Test and Set Lock (TSL) una variabile che effettua i
controlli.}

{}

\subparagraph{\texorpdfstring{{Semafori}}{Semafori}}\label{h.qkf29b2ix8jj}

{Per superare l'impossibilità della generalizzazione delle regioni
critiche (difficoltà nel risolvere problemi complessi) sono nati i
semafori.}

{Un semaforo ``S'' è una variabile intera cui si può accedere,
escludendo l'inizializzazione, solo tramite due operazioni atomiche
predefinite: wait() e signal().}

{}

{Al contrario del MUTEX, dove un processo deve detenere il mutex prima
di poter acquisire la risorsa, un semaforo è un meccanismo di
segnalazione dove i processi possono indicare se stanno acquisendo o
rilasciando la risorsa.}

{Quindi ricapitolando:}

\begin{itemize}
\tightlist
\item
  {I mutex hanno lo scopo di proteggere una risorsa condivisa, in modo
  che più processi non possano accedervi contemporaneamente;}
\item
  {un semaforo è un meccanismo di segnalazione tra processi e serve a
  condividere una risorsa che può essere usata contemporaneamente da un
  numero limitato di processi}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{Problemi
concorrenza}}{Problemi concorrenza}}\label{h.lbij5due5uj}

{Quando più processi concorrono per una risorsa e si applicano algoritmi
per gestirli si può incappare in alcuni errori:}

{}

\begin{itemize}
\tightlist
\item
  {Busy waiting: si verifica quando un thread attende il verificarsi di
  una condizione (come la modifica di un semaforo) e lo fa verificando
  continuamente se la condizione sia diventata vera. Questo consuma
  tempo in CPU;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Starvation: avviene se un thread in attesa di una certa risorsa, non
  riesce mai ad accedervi perché arrivano continue richieste da thread
  con privilegi maggiori;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Deadlock: due o più thread aspettano indefinitamente un evento che
  può essere causato solo da uno dei thread bloccati;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Producer \& Consumer: due processi condividono un buffer di
  dimensione limitata, il ``produttore'' riempie un buffer, un item alla
  volta, finchè non è pieno e il ``consumatore'' ~svuota il buffer, un
  item alla volta finchè non è vuoto;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Readers \& Writers: thread scrittori e lettori devono accedere in
  modo concorrente ad un file, dove più letture possono avvenire
  contemporaneamente ma le ~scritture sono esclusive;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {5 filosofi: in questo problema si usa un esempio dove ci sono 5 (o n,
  dove n\textgreater1) filosofi, che rappresentano i processi, a tavola
  per mangiare e pensare. Se un filosofo vuole mangiare deve usare due
  bastoncini ma tra un filosofo e l'altro c'e' un bastoncino solo, ogni
  filosofo può prendere solo una bacchetta alla volta e non può
  sottrarre bacchette dalle mani degli altri filosofi.}
\end{itemize}

{In questo esempio è impossibile che tutti i filosofi mangino allo
stesso tempo altrimenti si ruberebbero le risorse fra loro, per questo
in maniera alternata i filosofi devono mangiare e pensare.}

{}

{}

\subparagraph{\texorpdfstring{{Monitor}}{Monitor}}\label{h.h2rgztrv11jx}

{I monitor sono costrutti di livello più alto rispetto ai semafori, ogni
monitor è una struttura dati (o un oggetto) che permette la mutua
esclusione e la sincronizzazione su strutture dati condivise da più
thread ed un solo thread alla volta può essere attivo all'interno di un
monitor.}

{}

{Il monitor:}

{}

\begin{itemize}
\tightlist
\item
  {garantisce la mutua esclusione (un solo thread alla volta può
  eseguire il codice contenuto nel monitor);}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {la possibilità di usare metodi pubblici utilizzabili da processi;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {un insieme di variabili di condizione su cui possono essere invocate
  le primitive wait e signal.}
\end{itemize}

{}

{L'ipotesi fondamentale per la realizzazione di semafori e monitor è
l'esistenza di memoria condivisa a cui i diversi thread possono fare
riferimento; sfortunatamente nei S.O. moderni non esiste shared memory.}

{Per ovviare al problema si utilizzano tecniche di message passing.}

{}

{}

\paragraph{\texorpdfstring{{GESTIONE DELLA
MEMORIA}}{GESTIONE DELLA MEMORIA}}\label{h.u452h5khjm3z}

{Per funzionare c'è bisogno di due tipi di indirizzi che sono fra loro
uniti tramite un legame, questi indirizzi sono:}

{}

\begin{itemize}
\tightlist
\item
  {Indirizzo fisico: è l\textquotesingle indirizzo nello spazio di
  memoria centrale che individua in modo univoco una parola in esso
  contenuta;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Indirizzo logico: è astratto ed esiste solo
  all\textquotesingle interno dello spazio di indirizzamento del
  processo, e ne rappresenta}{~lo}{~spiazzamento rispetto alla prima
  parola. }{Questo indirizzo viene utilizzato come riferimento per
  accedere alla posizione di memoria fisica}{.}
\end{itemize}

{}

{La corrispondenza fra i due indirizzi può avvenire durante la
compilazione, durante il caricamento o in esecuzione.}

{}

\subparagraph{\texorpdfstring{{Rilocazione}}{Rilocazione}}\label{h.nrnm5g4tytg}

{È quando un programma viene allocato in memoria, quindi in questo
momento si decide l'indirizzo fisico che avrà.}

{La rilocazione avviene in maniera:}

{}

\begin{itemize}
\tightlist
\item
  {Statica: nel momento di esecuzione il }{S.O.,}{~tramite il LOADER,
  decide lo spazio di memoria dove andrà }{allocato}{~il processo.}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Dinamica: il programma viene caricato in memoria ogni esecuzione,
  andando a cambiare indirizzo.}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{MMU}}{MMU}}\label{h.xs4eotz5zb8q}

{Detto anche MEMORY-MANAGEMENT UNIT è un dispositivo con il compito di
eseguire la corrispondenza tra indirizzi in fase di esecuzione. Ciò è
possibile grazie al registro di rilocazione, dove la somma fra questo
valore e la parte indirizzo della istruzione (indirizzo logico) crea
l'indirizzo fisico.}

{}

\subparagraph{\texorpdfstring{{Politiche di
allocazione}}{Politiche di allocazione}}\label{h.a1dzw1nb6mcj}

{Insieme di regole per gestire la memoria, le politiche vengono valutate
tramite:}

{}

\begin{enumerate}
\tightlist
\item
  {Memoria sprecata;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Sovraccarico temporale: complessità computazionale delle operazioni
  di allocazione/deallocazione;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Sovraccarico nelle operazioni di accesso alla memoria}
\end{enumerate}

{}

{}

{}

{}

{}

{}

{Le allocazioni possono essere:}

{}

\begin{itemize}
\tightlist
\item
  {Contigue}{: i programmi salvati vengono messi uno dopo l'altro in
  base all'avvio, ne esistono 4 tipologie: }
\end{itemize}

\begin{enumerate}
\tightlist
\item
  {Monitor Monoprocesso}{: modo più semplice, la memoria viene divisa in
  due dove in una area viene allocata la parte residente del S.O. e
  nell'altra vengono allocati i processi transienti.}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Statica}{: suddividiamo la memoria in modo che in ogni partizione (di
  dimensione fissa) ~si possa caricare un programma e quindi fare
  eseguire un processo. Si usa il TDP, una tabella di descrizione delle
  partizioni, per monitorare ~lo stato delle partizioni.}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Dinamica}{: La suddivisione della memoria avviene dinamicamente in
  base alle esigenze dei processi, quindi non c'è il problema di non
  avere partizioni troppo piccole per alcuni processi; ~anche qui
  necessito del TDP in unione con una lista delle aree libere in
  memoria. Con la partizione dinamica abbiamo il problema della
  frammentazione esterna infatti si possono creare delle aree libere tra
  le partizioni che non possono essere utilizzate.}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {Segmentazione}{: creata per superare ~la frammentazione esterna,
  andando a ridurre le dimensioni delle zone allocate andando a dividere
  un programma in }{segmenti}{~che verrà allocato in modo contiguo.}
\end{enumerate}

{}

\begin{itemize}
\tightlist
\item
  {NON contigue}{: si basa sulla suddivisione del processo in pagine
  logiche con corrispondenti pagine fisiche. Sostanzialmente viene
  allocata solo la parte di programma utilizzato.}
\end{itemize}

{Questa tecnica è detta paging o paginazione, colui che si occupa di
caricare (}{swap-in}{) o deallocare (}{swap-out}{) è detto pager, se al
caricamento di una pagina il componente non la trova in memoria o c'è un
errore nella gestione degli indirizzi viene generato un page fault.}

{Quando avviene l'errore, dovuto alla mancanza della pagina, si genera
un segnale di }{trap}{~che informa il S.O, a questo punto il S.O. cerca
nel disco la pagina mancante e la carica nella memoria fisica; al
caricamento si modifica una tabella che ogni processo ha che indica
quali pagine contiene.}

{È cruciale scegliere bene il meccanismo di sostituzione delle pagine in
modo da ~tenere basso il numero dei page fault.}

{}

\subparagraph{\texorpdfstring{{Algoritmi di
caricamento}}{Algoritmi di caricamento}}\label{h.whntklshcew2}

{I diversi approcci alla scelta della pagina da scaricare sono:}

{}

\begin{enumerate}
\tightlist
\item
  {FIFO: l'algoritmo associa ad ogni pagina il tempo in cui è stata
  caricata in memoria e, se c'è necessità di scaricare una pagina,
  sceglie la pagina più vecchia;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Least Recently Used (LRU): l'algoritmo associa a ciascuna pagina
  l\textquotesingle istante in cui è stata usata per
  l\textquotesingle ultima volta e in caso di page fault con swap
  scarica la pagina che non viene acceduta da più tempo;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Least }{Frequently}{~Used }{(LFU):}{~viene usato un contatore che
  mantiene il numero degli accessi e viene }{scaricata}{~la pagina che
  ha avuto in numero minore di hit;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {Most Frequently Used (MFU): viene usato un contatore che mantiene il
  numero degli accessi e si scarica la pagina che ha avuto in numero
  maggiore di hit;}
\end{enumerate}

{}

{}

\paragraph{\texorpdfstring{{GESTIONE DEI FILE
SYSTEM}}{GESTIONE DEI FILE SYSTEM}}\label{h.8b5n8bbn92q7}

{Il file system è la parte del SO che si occupa di mantenere i
dati/programmi in modo persistente tramite file e directory.}

{}

\subparagraph{\texorpdfstring{{Accesso ai
file}}{Accesso ai file}}\label{h.dlwqekq9mnc1}

{In questo tipo di accesso i byte possono essere letti in qualsiasi
ordine, nei moderni sistemi operativi tutti i file sono automaticamente
ad accesso diretto.}

{}

{I file system esistenti sono tutti di tipo gerarchico è utilizzano i
}{path name}{~per indicare la posizione univoca di ogni file.}

{Si utilizza un grafo ad albero per determinare le posizioni, con la
radice principale detta ``root directory''; ogni file è univocamente
determinato dal cammino che lo collega alla radice.}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image44.png}}}

{}

\subparagraph{\texorpdfstring{{Implementazione
FS}}{Implementazione FS}}\label{h.5ew5hc1ouib7}

{Per creare un nostro FS dobbiamo risolvere 3 quesiti:}

{}

\begin{enumerate}
\tightlist
\item
  {Implementazione file}{: normalmente i dati sono memorizzati in unità
  di ampiezza fissa e si devono memorizzare gli attributi e la posizione
  dei singoli blocchi;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Implementazione directory}{: le cartelle sono file con uno specifico
  formato;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Gestione disco}{: per farlo dobbiamo tenere traccia della root
  directory e anche in quali spazi del disco ci sono file e dove no.}
\end{enumerate}

{}

{Implementazione file}

{Per allocare i file si può utilizzare la tecnica dell'allocazione
contigua che consiste nel memorizzare ogni file o in un gruppo di
blocchi contigui detti }{run}{.}

{Questo porta enormi svantaggi come la possibilità di sprecare spazio se
~l'ultimo blocco non è del tutto pieno e nel disco saranno presenti
buchi non grandi abbastanza per tenere altri file nelle parti di file
cancellate. }

{Esempio:}

{File allocati in maniera
contigua}{\pandocbounded{\includegraphics[keepaspectratio]{images/image43.png}}}

{}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image55.png}}}

{Caso di file più piccolo rispetto ai blocchi}

{Disco dopo la cancellazione di alcune
parti}{\pandocbounded{\includegraphics[keepaspectratio]{images/image53.png}}}

{}

{}

{Un'altra tecnica è quella delle liste concatenate, dove ogni blocco
contiene l'indirizzo di quello successivo, in questo modo non c'è
frammentazione esterna e il file può essere salvato su più parti di
memoria portando però ad }{un'accesso}{~alle informazioni molto lento.}

{}

{La tecnica principale usata da Unix è la }{Index-node}{~o }{i-node}{,
in questo modo solo gli i-node dei file in uso devono risiedere in RAM e
lo spazio è proporzionale al numero massimo di file aperti e non dipende
dall'ampiezza del disco.}

{Infatti ogni }{i-node}{~ha associato un numero univoco
all\textquotesingle interno del dispositivo e ogni file presente è
identificato come un
}{\href{https://www.google.com/url?q=https://it.wikipedia.org/wiki/Collegamento_fisico&sa=D&source=editors&ust=1734623862793589&usg=AOvVaw2_-hwq0oPlMALEaGwhU0s4}{collegamento
fisico}}{~all\textquotesingle i-node tramite il suo numero. Quando un
programma cerca di accedere ad un file tramite un nome (es.
}{documento.txt}{), il
}{\href{https://www.google.com/url?q=https://it.wikipedia.org/wiki/Sistema_operativo&sa=D&source=editors&ust=1734623862793720&usg=AOvVaw1xNjyHMD1Dg58Ak8bo2Gzf}{sistema
operativo}}{~cerca l\textquotesingle i-node corrispondente e recupera
tutte le informazioni sopra descritte per operare correttamente con il
file.}

{}

{Implementazione Directory}

{Devono permettere di recuperare tutte le informazioni relative ai file
contenuti il punto fondamentale è associare il nome del file ad
attributi e dati (indirizzo/i dei blocchi).}

{}

{La soluzione più semplice è far contenere alla directory una tabella
con un elemento per ogni file, dove attributi e indirizzi dei blocchi
del file X sono memorizzati direttamente nell'elemento della tabella
relativo ad X (usata da FAT).}

{}

{Gestione disco}

{Tutti i FS dividono i file in blocchi NON CONTIGUI di ampiezza fissata
ed eseguono letture e scritture su blocchi o multipli.}

{}

{Per decidere l'ampiezza dei blocchi dobbiamo chiederci che
caratteristica vogliamo per il nostro FS, con blocchi piccoli usiamo
meglio lo spazio disco (diminuiscono la frammentazione interna) con
blocchi grandi }{velocizziamo}{~gli accessi.}

{}

{Per tenere traccia dei blocchi liberi su disco abbiamo 2 alternative:}

{}

\begin{enumerate}
\tightlist
\item
  {Free list: lista concatenata di blocchi pieni di indirizzi di blocchi
  liberi;}
\item
  {Bitmap: ~una mappa di bit con un bit per ogni blocco, mantiene la
  contiguità dei blocchi.}
\end{enumerate}

{Esempio}{:}

{\pandocbounded{\includegraphics[keepaspectratio]{images/image57.png}}}

{Gestione errori e affidabilità}

{Se una traccia ha un settore difettoso il FS in automatico sostituisce
il settore difettoso con uno di riserva, andando a slittare tutto per
evitare il problema.}

{}

{Il FS esegue backup periodici in caso di crash e problemi accidentali
in modo da non perdere dati.}

{}

{Con }{Stable Storage}{~si indica una tecnica che permette di mettersi
al riparo da errori che si verificano durante una scrittura, infatti
nello stable storage, ogni volta che eseguiamo una write si garantisce
che il valore scritto è corretto oppure è uguale a quello vecchio.}

{}

{}

\paragraph{\texorpdfstring{{GESTIONE DISPOSITIVI
I/O}}{GESTIONE DISPOSITIVI I/O}}\label{h.5y5jh9u1pu1e}

{I dispositivi I/O sono molti ed eterogenei con obiettivi differenti
(memorizzazione, trasmissione, interazione, ecc) per questo è necessario
uniformare gli standard per alleggerire la loro gestione da parte del
S.O.}

{Il kernel ha un sottosistema apposito per la gestione I/O con driver
che offrono un\textquotesingle interfaccia uniforme per l'accesso ai
dispositivi.}

{Alcuni meccanismi hardware sono comuni fra tutti i dispositivi, e
sono:}

{}

\begin{itemize}
\tightlist
\item
  {Porta: punto di connessione fisica (via cavo o etere) tra il sistema
  di calcolo e il device di I/O;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Bus: insieme di connessioni al sistema di calcolo utilizzate da più
  dispositivi contemporaneamente;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Controller: processore dedicato con microcodice che svolge attività
  specializzate sul device di I/O.}
\end{itemize}

{}

\subparagraph{\texorpdfstring{{Registri e
controller}}{Registri e controller}}\label{h.5zn0ct36eqin}

{Tipicamente una porta di I/O opera sulla base di 4 registri: }

{}

\begin{enumerate}
\tightlist
\item
  {Status: bit che indicano lo stato della porta ;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{1}
\tightlist
\item
  {Control: viene usato per attivare un comando o per cambiare il modo
  operativo del dispositivo;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{2}
\tightlist
\item
  {Data-in: byte disponibili in lettura;}
\end{enumerate}

{}

\begin{enumerate}
\setcounter{enumi}{3}
\tightlist
\item
  {Data-out: byte disponibili in scrittura.}
\end{enumerate}

{}

{Per accedere ai registri si usa il controller e l'accesso può
avvenire:}

{}

\begin{itemize}
\tightlist
\item
  {Mappando i dispositivi in memoria: i registri sono visti nello spazio
  di indirizzamento della memoria, ciò permette di scrivere driver in
  linguaggio ad alto livello andando a sacrificare la protezione;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Mappando i dispositivi sull' I/O: si accede ai registri tramite
  istruzioni specifiche evitando problemi di gestione cache.}
\end{itemize}

{}

{Comunicazione controller}

{Per comunicare con il controller possiamo usare diversi modi:}

{}

\begin{itemize}
\tightlist
\item
  {Polling}{: la CPU controlla periodicamente lo stato del controller
  per verificare se }{una operazione}{~è completata o no. }
\end{itemize}

{Si basa sul paradigma handshaking con l'utilizzo di 2 bit per
coordinare la relazione produttore/consumatore (il 1° detto bit busy, il
2° command ready); chi controlla il bit busy è in polling.}

{Questo procedimento diventa inefficiente perchè, sebbene le
interrogazioni siano frequenti, si trova raramente un dispositivo
libero;}

{}

\begin{itemize}
\tightlist
\item
  {Interrupt}{: il controller segnala alla CPU il completamento
  dell'operazione richiesta, infatti è presente un hardware apposito, la
  linea di richiesta dell'interrupt, controllato direttamente dalla
  CPU.}
\end{itemize}

{Quando si rileva un segnale la CPU blocca quello che sta facendo ed
esegue una routine apposita detta }{interrupt handler}{, il compito
della routine è quello di determinare perché la CPU si è bloccata e
portare a termine l'operazione I/O; ~}

{}

\begin{itemize}
\tightlist
\item
  {DMA }{(Direct Memory Access): la segnalazione alla CPU viene mandata
  per blocchi e non per byte, grazie ad un accesso diretto del
  controller DMA sulla memoria centrale. Inoltre la CPU interviene
  direttamente nella gestione degli interrupt e questa attività è molto
  dispersiva, per questo ~può essere utile un controller dedicato che
  trasferisca i dati direttamente dall'I/O alla memoria centrale senza
  contattare la CPU.}
\end{itemize}

{Il nuovo controller DMA trasferisce su 2 livelli:}

\begin{enumerate}
\tightlist
\item
  {CPU-DMA}{: la CPU chiede al controller DMA di avviare il
  trasferimento e il controller DMA segnala il completamento (tramite
  interrupt);}
\item
  {DMA-Device Controller-Memoria}{: il controller DMA agisce trasferendo
  i dati dalla memoria centrale al controller del device e viceversa.}
\end{enumerate}

{}

{}

\subparagraph{\texorpdfstring{{Interfacce per applicazioni
{[}Driver{]}}}{Interfacce per applicazioni {[}Driver{]}}}\label{h.vg3m2ua8rch4}

{Il S.O. deve offrire alle applicazioni un\textquotesingle interfaccia
astratta per far utilizzare il sistema I/O alle applicazioni, per farlo
si }{necessita}{~dei driver.}

{}

{I driver costituiscono dunque lo strato del S.O. più vicino
all'hardware dell'I/O. È un software, spesso scritto in assembly, che
permette ad un sistema operativo di pilotare un dispositivo hardware.}

{In questo modo il S.O. agisce in modo indipendente dall'hardware e
questo va a vantaggio di chi implementa il S.O. e di chi produce
hardware.}

{}

\subparagraph{\texorpdfstring{{Sottosistema I/O -
Servizi}}{Sottosistema I/O - Servizi}}\label{h.2chjezwgprj}

{I principali servizi offerti dal sottosistema di I/O del kernel sono:}

{}

\begin{itemize}
\tightlist
\item
  {Scheduling}{: cioè gestire l'ordine con cui le richieste di I/O sono
  gestite, il problema è particolarmente rilevante nella gestione degli
  accessi al disco;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Buffering}{: si utilizza un buffer, cioè una regione di memoria che
  contiene dati mentre questi sono trasferiti da un dispositivo, per
  permettere la bufferizzazione. La tecnica è essenziale perché i
  dispositivi potrebbero avere velocità diverse oppure avere diverse
  dimensioni dei blocchi trasferiti. Un'altra importante caratteristica
  è la semantica di copia, cioè garantire che la versione dei dati
  scritta su un dispositivo sia la stessa versione presente in memoria;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Caching}{. si utilizza una cache per migliorare le prestazioni dei
  dispositivi di I/O, al contrario del buffer la cache non può contenere
  dati di cui non esiste altra copia;}
\end{itemize}

{}

\begin{itemize}
\tightlist
\item
  {Spooling}{: si utilizza lo spool, cioè un buffer
  }{contenente}{~output per dispositivi che non possono accettare flussi
  di dati da più processi contemporaneamente, come ad esempio la
  stampante.}
\end{itemize}

{Lo spooler è l\textquotesingle unico programma che ha accesso diretto
alla periferica, e gestisce il buffer offrendo agli utenti alcune
operazioni aggiuntive come la visualizzazione della coda di attesa dei
processi o la cancellazione/sospensione di uno di essi.}

{}

{}

{}

\end{document}
